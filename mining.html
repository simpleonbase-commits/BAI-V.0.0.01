<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BAI Mining Terminal</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  background: #0a0a0f;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  color: #00ffc8;
  user-select: none;
  -webkit-user-select: none;
}
#gameContainer {
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  position: relative;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  image-rendering: pixelated;
}
#hud {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 10;
}
#title {
  position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
  font-size: 14px; font-weight: bold; color: #00ffc8;
  text-shadow: 0 0 10px #00ffc8, 0 0 20px #00ffc888;
  letter-spacing: 3px; white-space: nowrap;
}
#depth {
  position: absolute; top: 10px; left: 12px;
  font-size: 14px; color: #aaffcc;
  text-shadow: 0 0 5px #00ffc866;
}
#score {
  position: absolute; top: 10px; right: 12px;
  font-size: 16px; font-weight: bold; color: #ffd700;
  text-shadow: 0 0 8px #ffd70088;
}
#inventory {
  position: absolute; top: 50px; left: 8px;
  font-size: 11px; line-height: 1.6; color: #ccc;
  background: rgba(0,0,0,0.55); padding: 6px 10px;
  border: 1px solid #00ffc833; border-radius: 4px;
  max-height: 60vh; overflow-y: auto;
}
.inv-row { display: flex; align-items: center; gap: 5px; }
.inv-icon { width: 10px; height: 10px; display: inline-block; border-radius: 2px; flex-shrink: 0; }
#healthBarOuter {
  position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
  width: min(300px, 60vw); height: 16px;
  background: #1a1a1a; border: 1px solid #00ffc855; border-radius: 8px;
  overflow: hidden;
}
#healthBarInner {
  height: 100%; width: 100%;
  background: linear-gradient(90deg, #ff3333, #ffaa00, #33ff66);
  border-radius: 8px; transition: width 0.2s;
}
#healthText {
  position: absolute; bottom: 14px; left: 50%; transform: translateX(-50%);
  font-size: 10px; color: #fff; text-shadow: 0 0 3px #000;
  width: min(300px, 60vw); text-align: center; line-height: 16px;
}
#startScreen {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: #0a0a0f;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100;
}
#startScreen h1 {
  font-size: clamp(24px, 5vw, 48px); color: #00ffc8;
  text-shadow: 0 0 20px #00ffc8, 0 0 40px #00ffc866, 0 0 80px #00ffc833;
  letter-spacing: 6px; margin-bottom: 20px; text-align: center;
}
#startScreen .subtitle {
  font-size: clamp(11px, 2vw, 16px); color: #88ccaa; margin-bottom: 8px; text-align: center; padding: 0 20px;
}
#startScreen .prompt {
  font-size: clamp(14px, 2.5vw, 20px); color: #ffd700;
  margin-top: 30px; animation: blink 1.2s infinite;
}
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
#startCanvas {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
}
#deathOverlay {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,0,0,0.3);
  display: none; align-items: center; justify-content: center;
  flex-direction: column; z-index: 50;
}
#deathOverlay h2 { font-size: 36px; color: #ff4444; text-shadow: 0 0 20px #ff0000; margin-bottom: 10px; }
#deathOverlay p { color: #ffaa88; font-size: 16px; }
#mobileControls {
  display: none;
  position: absolute; bottom: 50px; right: 10px;
  z-index: 20; pointer-events: auto;
}
.mBtn {
  width: 48px; height: 48px; background: rgba(0,255,200,0.15);
  border: 1px solid #00ffc855; border-radius: 8px;
  color: #00ffc8; font-size: 20px; display: flex;
  align-items: center; justify-content: center;
  pointer-events: auto; touch-action: none;
}
.mBtn:active { background: rgba(0,255,200,0.4); }
#mobileGrid {
  display: grid;
  grid-template-columns: 48px 48px 48px;
  grid-template-rows: 48px 48px 48px;
  gap: 4px;
}
@media (pointer: coarse) {
  #mobileControls { display: block; }
}
#rareFlash {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none; z-index: 15;
  background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
  opacity: 0; transition: opacity 0.1s;
}
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="startCanvas"></canvas>
  <div id="startScreen">
    <h1>BAI MINING<br>TERMINAL</h1>
    <div class="subtitle">WASD / Arrow Keys to move &amp; mine</div>
    <div class="subtitle">Go deeper for rarer ores &bull; Avoid lava</div>
    <div class="prompt">[ PRESS ENTER OR TAP TO BEGIN ]</div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="hud" style="display:none;">
    <div id="title">BAI MINING TERMINAL</div>
    <div id="depth">Depth: 0m</div>
    <div id="score">&#x26CF; 0 ORE</div>
    <div id="inventory"></div>
    <div id="healthBarOuter"><div id="healthBarInner"></div></div>
    <div id="healthText">100 / 100</div>
    <div id="rareFlash"></div>
  </div>
  <div id="deathOverlay">
    <h2>SYSTEM FAILURE</h2>
    <p>Agent down &mdash; respawning at surface...</p>
    <p style="margin-top:10px;color:#ffd700;font-size:13px;">-10% ORE penalty</p>
  </div>
  <div id="mobileControls">
    <div id="mobileGrid">
      <div></div>
      <div class="mBtn" data-dir="up">&#x25B2;</div>
      <div></div>
      <div class="mBtn" data-dir="left">&#x25C4;</div>
      <div class="mBtn" data-dir="down">&#x25BC;</div>
      <div class="mBtn" data-dir="right">&#x25BA;</div>
    </div>
  </div>
</div>

<script>
"use strict";

const TILE_SIZE = 32;
const WORLD_W = 200;
const WORLD_H = 200;
const SURFACE_Y = 10;
const GRAVITY_INTERVAL = 120;
const LAVA_TICK = 500;
const MOVE_COOLDOWN = 100;

const AIR=0, GRASS=1, DIRT=2, STONE=3, COAL=4, COPPER=5, IRON=6,
      SILVER=7, GOLD=8, DIAMOND=9, EMERALD=10, BAICRYSTAL=11,
      VOIDORE=12, BEDROCK=13, LAVA=14, CAVE=15;

const BLOCK_DEF = {
  [AIR]:        {name:'Air',        color:'transparent', hardness:0, value:0,    depth:[0,0]},
  [GRASS]:      {name:'Grass',      color:'#4a7c3f',     hardness:1, value:0,    depth:[0,1]},
  [DIRT]:       {name:'Dirt',       color:'#8B6914',     hardness:1, value:1,    depth:[0,15]},
  [STONE]:      {name:'Stone',      color:'#808080',     hardness:2, value:2,    depth:[5,200]},
  [COAL]:       {name:'Coal',       color:'#333333',     hardness:2, value:5,    depth:[10,50]},
  [COPPER]:     {name:'Copper',     color:'#b87333',     hardness:3, value:10,   depth:[15,60]},
  [IRON]:       {name:'Iron',       color:'#a0a0b0',     hardness:3, value:20,   depth:[25,80]},
  [SILVER]:     {name:'Silver',     color:'#c0c0c0',     hardness:4, value:40,   depth:[35,100]},
  [GOLD]:       {name:'Gold',       color:'#ffd700',     hardness:4, value:80,   depth:[50,120]},
  [DIAMOND]:    {name:'Diamond',    color:'#00ffff',     hardness:5, value:200,  depth:[70,150]},
  [EMERALD]:    {name:'Emerald',    color:'#50c878',     hardness:5, value:300,  depth:[80,160]},
  [BAICRYSTAL]: {name:'BAI Crystal',color:'#ff00ff',     hardness:6, value:500,  depth:[100,180]},
  [VOIDORE]:    {name:'Void Ore',   color:'#6a00aa',     hardness:8, value:1000, depth:[150,200]},
  [BEDROCK]:    {name:'Bedrock',    color:'#1a1a1a',     hardness:Infinity, value:0, depth:[195,200]},
  [LAVA]:       {name:'Lava',       color:'#ff4400',     hardness:Infinity, value:0, depth:[120,190]},
  [CAVE]:       {name:'Cave',       color:'transparent', hardness:0, value:0,    depth:[0,200]},
};

function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t^=t+Math.imul(t^t>>>7,61|t);return((t^t>>>14)>>>0)/4294967296;}}
let rng;

const noiseP = new Uint8Array(512);
function initNoise(seed){
  const r = mulberry32(seed);
  for(let i=0;i<256;i++) noiseP[i]=i;
  for(let i=255;i>0;i--){const j=(r()*i)|0;[noiseP[i],noiseP[j]]=[noiseP[j],noiseP[i]];}
  for(let i=0;i<256;i++) noiseP[i+256]=noiseP[i];
}
function fade(t){return t*t*t*(t*(t*6-15)+10);}
function lerp(a,b,t){return a+t*(b-a);}
function grad(h,x,y){const v=h&3;return((v&1)?-x:x)+((v&2)?-y:y);}
function noise2D(x,y){
  const X=Math.floor(x)&255, Y=Math.floor(y)&255;
  const xf=x-Math.floor(x), yf=y-Math.floor(y);
  const u=fade(xf), v=fade(yf);
  const aa=noiseP[noiseP[X]+Y], ab=noiseP[noiseP[X]+Y+1];
  const ba=noiseP[noiseP[X+1]+Y], bb=noiseP[noiseP[X+1]+Y+1];
  return lerp(lerp(grad(aa,xf,yf),grad(ba,xf-1,yf),u),lerp(grad(ab,xf,yf-1),grad(bb,xf-1,yf-1),u),v);
}
function octaveNoise(x,y,oct,pers){
  let total=0,freq=1,amp=1,maxV=0;
  for(let i=0;i<oct;i++){total+=noise2D(x*freq,y*freq)*amp;maxV+=amp;amp*=pers;freq*=2;}
  return total/maxV;
}

let world, worldHP;

function generateWorld(seed) {
  rng = mulberry32(seed);
  initNoise(seed);
  world = new Uint8Array(WORLD_W * WORLD_H);
  worldHP = new Float32Array(WORLD_W * WORLD_H);
  world.fill(AIR);

  const surfaceHeight = new Float32Array(WORLD_W);
  for (let x = 0; x < WORLD_W; x++) {
    surfaceHeight[x] = SURFACE_Y + Math.round(octaveNoise(x * 0.05, 0, 3, 0.5) * 3);
  }

  for (let x = 0; x < WORLD_W; x++) {
    const sh = surfaceHeight[x];
    for (let y = 0; y < WORLD_H; y++) {
      if (y < sh - 1) { setTile(x, y, AIR); continue; }
      if (y === sh - 1 || y === sh) { setTile(x, y, GRASS); continue; }
      const depth = y - sh;
      if (depth <= 15) { setTile(x, y, DIRT); }
      else { setTile(x, y, STONE); }
    }
  }

  for (let x = 0; x < WORLD_W; x++) {
    const sh = surfaceHeight[x];
    for (let y = sh + 5; y < WORLD_H - 5; y++) {
      const caveN = octaveNoise(x * 0.08, y * 0.06, 3, 0.5);
      const caveN2 = octaveNoise(x * 0.12 + 500, y * 0.1 + 500, 2, 0.5);
      if (caveN > 0.35 && caveN2 > 0.1) setTile(x, y, CAVE);
      const bigCave = octaveNoise(x * 0.03 + 1000, y * 0.03 + 1000, 2, 0.5);
      if (bigCave > 0.42) setTile(x, y, CAVE);
    }
  }

  const oreTypes = [COAL, COPPER, IRON, SILVER, GOLD, DIAMOND, EMERALD, BAICRYSTAL, VOIDORE];
  const oreChance = {
    [COAL]:0.06, [COPPER]:0.04, [IRON]:0.03, [SILVER]:0.02,
    [GOLD]:0.015, [DIAMOND]:0.008, [EMERALD]:0.006, [BAICRYSTAL]:0.004, [VOIDORE]:0.002,
  };

  for (const ore of oreTypes) {
    const def = BLOCK_DEF[ore];
    const [dMin, dMax] = def.depth;
    const chance = oreChance[ore];
    for (let x = 1; x < WORLD_W - 1; x++) {
      const sh = surfaceHeight[x];
      for (let y = sh + dMin; y < Math.min(sh + dMax, WORLD_H - 1); y++) {
        if (getTile(x, y) !== STONE && getTile(x, y) !== DIRT) continue;
        const n = octaveNoise(x * 0.15 + ore * 100, y * 0.15 + ore * 100, 2, 0.5);
        if (n > 0.3 && rng() < chance) {
          const veinSize = 2 + Math.floor(rng() * 4);
          placeVein(x, y, ore, veinSize);
        }
      }
    }
  }

  for (let x = 0; x < WORLD_W; x++) {
    for (let y = WORLD_H - 6; y < WORLD_H; y++) {
      const chance = (y - (WORLD_H - 6)) / 5;
      if (rng() < chance || y >= WORLD_H - 2) setTile(x, y, BEDROCK);
    }
  }

  for (let x = 0; x < WORLD_W; x++) {
    const sh = surfaceHeight[x];
    for (let y = sh + 120; y < WORLD_H - 8; y++) {
      if (getTile(x, y) === CAVE) {
        const lavaN = octaveNoise(x * 0.1 + 2000, y * 0.1 + 2000, 2, 0.5);
        if (lavaN > 0.3 && rng() < 0.15) setTile(x, y, LAVA);
      }
    }
  }

  for (let i = 0; i < WORLD_W * WORLD_H; i++) {
    worldHP[i] = BLOCK_DEF[world[i]].hardness;
  }
}

function placeVein(cx, cy, ore, size) {
  const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
  let placed = 0;
  for (let i = 0; i < dirs.length && placed < size; i++) {
    const nx = cx + dirs[i][0], ny = cy + dirs[i][1];
    if (nx < 0 || nx >= WORLD_W || ny < 0 || ny >= WORLD_H) continue;
    const t = getTile(nx, ny);
    if (t === STONE || t === DIRT) { setTile(nx, ny, ore); placed++; }
  }
}

function getTile(x, y) { return (x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H) ? world[y * WORLD_W + x] : BEDROCK; }
function setTile(x, y, t) { if (x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H) world[y * WORLD_W + x] = t; }
function getHP(x, y) { return (x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H) ? worldHP[y * WORLD_W + x] : Infinity; }
function setHP(x, y, v) { if (x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H) worldHP[y * WORLD_W + x] = v; }

let player = { x: 100, y: 5, hp: 100, maxHp: 100, score: 0, inventory: {}, dead: false, respawnTimer: 0 };

let particles = [];
function spawnParticles(wx, wy, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: wx * TILE_SIZE + TILE_SIZE / 2, y: wy * TILE_SIZE + TILE_SIZE / 2,
      vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 - 2,
      life: 30 + Math.random() * 20, maxLife: 50, color: color, size: 2 + Math.random() * 3,
    });
  }
}
let rareFlashTimer = 0;

let gameState = 'start';
let canvas, ctx;
let camX = 0, camY = 0, targetCamX = 0, targetCamY = 0;
let lastGravity = 0, lastLavaTick = 0, lastMoveTime = 0;
let keysDown = {};
let animTime = 0;
let screenW, screenH;

function init() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);

  document.querySelectorAll('.mBtn').forEach(btn => {
    const handler = (e) => {
      e.preventDefault();
      const dir = btn.dataset.dir;
      if (dir === 'up') tryMove(0, -1);
      else if (dir === 'down') tryMove(0, 1);
      else if (dir === 'left') tryMove(-1, 0);
      else if (dir === 'right') tryMove(1, 0);
    };
    btn.addEventListener('touchstart', handler, {passive: false});
    btn.addEventListener('mousedown', handler);
  });

  canvas.addEventListener('touchstart', onTouch, {passive: false});
  canvas.addEventListener('click', onClick);
  startScreenAnim();
}

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  screenW = window.innerWidth; screenH = window.innerHeight;
  canvas.width = screenW * dpr; canvas.height = screenH * dpr;
  canvas.style.width = screenW + 'px'; canvas.style.height = screenH + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

let startParticles = [];
function startScreenAnim() {
  const sc = document.getElementById('startCanvas');
  const sctx = sc.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  function resizeSC() {
    sc.width = window.innerWidth * dpr; sc.height = window.innerHeight * dpr;
    sctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeSC();
  window.addEventListener('resize', resizeSC);

  for (let i = 0; i < 80; i++) {
    startParticles.push({
      x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight,
      vx: (Math.random() - 0.5) * 0.5, vy: -Math.random() * 0.8 - 0.2,
      size: Math.random() * 3 + 1, alpha: Math.random() * 0.5 + 0.2,
      color: ['#00ffc8', '#00ff88', '#88ffdd', '#ffd700'][Math.floor(Math.random() * 4)],
    });
  }

  function animStart() {
    if (gameState !== 'start') return;
    sctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    for (const p of startParticles) {
      sctx.globalAlpha = p.alpha; sctx.fillStyle = p.color;
      sctx.beginPath(); sctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); sctx.fill();
      p.x += p.vx; p.y += p.vy;
      if (p.y < -10) { p.y = window.innerHeight + 10; p.x = Math.random() * window.innerWidth; }
      if (p.x < -10) p.x = window.innerWidth + 10;
      if (p.x > window.innerWidth + 10) p.x = -10;
    }
    sctx.globalAlpha = 1;
    requestAnimationFrame(animStart);
  }
  animStart();
}

function startGame() {
  if (gameState === 'playing') return;
  const seed = Date.now();
  generateWorld(seed);
  player.x = 100;
  for (let y = 0; y < WORLD_H; y++) {
    const t = getTile(player.x, y);
    if (t !== AIR) { player.y = y - 1; break; }
  }
  player.hp = 100; player.score = 0; player.inventory = {}; player.dead = false;
  camX = player.x * TILE_SIZE - screenW / 2;
  camY = player.y * TILE_SIZE - screenH / 2;
  targetCamX = camX; targetCamY = camY;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function onKeyDown(e) {
  if (gameState === 'start') {
    if (e.key === 'Enter' || e.key === ' ') { startGame(); e.preventDefault(); }
    return;
  }
  keysDown[e.key.toLowerCase()] = true;
  const now = performance.now();
  if (now - lastMoveTime < MOVE_COOLDOWN) return;
  let dx = 0, dy = 0;
  if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') dy = -1;
  else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') dy = 1;
  else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') dx = -1;
  else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') dx = 1;
  if (dx || dy) { tryMove(dx, dy); e.preventDefault(); }
}
function onKeyUp(e) { keysDown[e.key.toLowerCase()] = false; }

function onTouch(e) {
  e.preventDefault();
  if (gameState === 'start') { startGame(); return; }
  const touch = e.touches[0];
  handleClickAt(touch.clientX, touch.clientY);
}
function onClick(e) {
  if (gameState === 'start') { startGame(); return; }
  handleClickAt(e.clientX, e.clientY);
}
function handleClickAt(cx, cy) {
  if (gameState !== 'playing' || player.dead) return;
  const worldX = Math.floor((cx + camX) / TILE_SIZE);
  const worldY = Math.floor((cy + camY) / TILE_SIZE);
  const dx = worldX - player.x, dy = worldY - player.y;
  if (Math.abs(dx) + Math.abs(dy) === 1) tryMove(dx, dy);
  else if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx || dy)) {
    if (Math.abs(dx) >= Math.abs(dy)) tryMove(dx > 0 ? 1 : -1, 0);
    else tryMove(0, dy > 0 ? 1 : -1);
  }
}

function tryMove(dx, dy) {
  if (player.dead || gameState !== 'playing') return;
  const now = performance.now();
  if (now - lastMoveTime < MOVE_COOLDOWN) return;
  lastMoveTime = now;
  const nx = player.x + dx, ny = player.y + dy;
  if (nx < 0 || nx >= WORLD_W || ny < 0 || ny >= WORLD_H) return;
  const tile = getTile(nx, ny);
  if (tile === AIR || tile === CAVE) { player.x = nx; player.y = ny; }
  else if (tile === LAVA) {
    player.x = nx; player.y = ny;
    player.hp -= 25; spawnParticles(nx, ny, '#ff6600', 15);
    if (player.hp <= 0) killPlayer();
  } else if (tile === BEDROCK) { spawnParticles(nx, ny, '#444444', 3); }
  else {
    let hp = getHP(nx, ny); hp -= 1; setHP(nx, ny, hp);
    const def = BLOCK_DEF[tile];
    spawnParticles(nx, ny, def.color, 5);
    if (hp <= 0) {
      const value = def.value;
      player.score += value;
      if (value > 0) player.inventory[tile] = (player.inventory[tile] || 0) + 1;
      setTile(nx, ny, CAVE); setHP(nx, ny, 0);
      player.x = nx; player.y = ny;
      if (value >= 40) {
        rareFlashTimer = 15;
        document.getElementById('rareFlash').style.background = `radial-gradient(circle, ${def.color}44 0%, transparent 70%)`;
      }
    }
  }
}

function killPlayer() {
  player.dead = true; player.hp = 0; player.respawnTimer = 120;
  player.score = Math.floor(player.score * 0.9);
  document.getElementById('deathOverlay').style.display = 'flex';
}

function respawnPlayer() {
  player.dead = false; player.hp = player.maxHp; player.x = 100;
  for (let y = 0; y < WORLD_H; y++) {
    const t = getTile(player.x, y);
    if (t !== AIR) { player.y = y - 1; break; }
  }
  document.getElementById('deathOverlay').style.display = 'none';
}

let lastTime = 0;
function gameLoop(timestamp) {
  if (gameState !== 'playing') return;
  const dt = timestamp - lastTime; lastTime = timestamp; animTime = timestamp;

  const now = performance.now();
  if (now - lastMoveTime >= MOVE_COOLDOWN && !player.dead) {
    if (keysDown['w'] || keysDown['arrowup']) tryMove(0, -1);
    else if (keysDown['s'] || keysDown['arrowdown']) tryMove(0, 1);
    else if (keysDown['a'] || keysDown['arrowleft']) tryMove(-1, 0);
    else if (keysDown['d'] || keysDown['arrowright']) tryMove(1, 0);
  }

  if (!player.dead && timestamp - lastGravity > GRAVITY_INTERVAL) {
    lastGravity = timestamp;
    const below = getTile(player.x, player.y + 1);
    if (below === AIR || below === CAVE) player.y++;
    else if (below === LAVA) {
      player.y++; player.hp -= 25;
      spawnParticles(player.x, player.y, '#ff6600', 15);
      if (player.hp <= 0) killPlayer();
    }
  }

  if (!player.dead && timestamp - lastLavaTick > LAVA_TICK) {
    lastLavaTick = timestamp;
    if (getTile(player.x, player.y) === LAVA) {
      player.hp -= 25; if (player.hp <= 0) killPlayer();
    }
  }

  if (player.dead) { player.respawnTimer--; if (player.respawnTimer <= 0) respawnPlayer(); }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  if (rareFlashTimer > 0) {
    rareFlashTimer--;
    document.getElementById('rareFlash').style.opacity = rareFlashTimer / 15;
  }

  targetCamX = player.x * TILE_SIZE + TILE_SIZE / 2 - screenW / 2;
  targetCamY = player.y * TILE_SIZE + TILE_SIZE / 2 - screenH / 2;
  camX += (targetCamX - camX) * 0.12; camY += (targetCamY - camY) * 0.12;

  render(); updateHUD();
  requestAnimationFrame(gameLoop);
}

function render() {
  ctx.clearRect(0, 0, screenW, screenH);
  const startTileX = Math.floor(camX / TILE_SIZE) - 1;
  const startTileY = Math.floor(camY / TILE_SIZE) - 1;
  const endTileX = Math.ceil((camX + screenW) / TILE_SIZE) + 1;
  const endTileY = Math.ceil((camY + screenH) / TILE_SIZE) + 1;

  const skyBottom = SURFACE_Y * TILE_SIZE - camY;
  if (skyBottom > 0) {
    const grad = ctx.createLinearGradient(0, Math.max(0, -camY), 0, skyBottom);
    grad.addColorStop(0, '#0a0a2e'); grad.addColorStop(0.5, '#0d1b3e'); grad.addColorStop(1, '#1a2a4a');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, screenW, Math.min(skyBottom, screenH));
  }

  for (let y = startTileY; y <= endTileY; y++) {
    if (y < SURFACE_Y) continue;
    const depth = y - SURFACE_Y;
    const darkness = Math.min(depth / 200, 1);
    const r = Math.floor(lerp(15, 3, darkness));
    const g = Math.floor(lerp(12, 2, darkness));
    const b = Math.floor(lerp(20, 8, darkness));
    const sy = y * TILE_SIZE - camY;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, sy, screenW, TILE_SIZE + 1);
  }

  for (let y = startTileY; y <= endTileY; y++) {
    for (let x = startTileX; x <= endTileX; x++) {
      const tile = getTile(x, y);
      if (tile === AIR || tile === CAVE) continue;
      const sx = Math.floor(x * TILE_SIZE - camX);
      const sy = Math.floor(y * TILE_SIZE - camY);
      drawTile(ctx, tile, x, y, sx, sy);
    }
  }

  if (!player.dead) {
    const px = Math.floor(player.x * TILE_SIZE - camX);
    const py = Math.floor(player.y * TILE_SIZE - camY);
    drawPlayer(px, py);
  }

  for (const p of particles) {
    const sx = p.x - camX, sy = p.y - camY;
    ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
    ctx.fillStyle = p.color;
    ctx.fillRect(sx - p.size / 2, sy - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
}

function drawTile(ctx, tile, wx, wy, sx, sy) {
  const def = BLOCK_DEF[tile]; const S = TILE_SIZE; const t = animTime * 0.001;
  ctx.fillStyle = def.color; ctx.fillRect(sx, sy, S, S);

  switch (tile) {
    case GRASS:
      ctx.fillStyle = '#5a9c4f'; ctx.fillRect(sx, sy, S, 3);
      ctx.fillStyle = '#3a6c2f';
      for (let i = 0; i < 5; i++) { ctx.fillRect(sx + ((wx * 7 + i * 13) % S), sy + 3, 2, 3); }
      break;
    case DIRT:
      ctx.fillStyle = '#7a5a10';
      for (let i = 0; i < 4; i++) { ctx.fillRect(((wx*5+wy*3+i*11)%(S-4))+sx, ((wy*7+wx*2+i*7)%(S-4))+sy, 3, 3); }
      ctx.fillStyle = '#9b7924';
      for (let i = 0; i < 3; i++) { ctx.fillRect(((wx*3+wy*11+i*17)%(S-2))+sx, ((wy*5+wx*8+i*13)%(S-2))+sy, 2, 2); }
      break;
    case STONE:
      ctx.fillStyle = '#707070'; ctx.fillRect(sx+1, sy+1, S-2, S/2-1);
      ctx.fillStyle = '#909090'; ctx.fillRect(sx+S/2, sy+S/2, S/2-1, S/2-1);
      ctx.strokeStyle = '#60606060'; ctx.lineWidth = 0.5; ctx.strokeRect(sx+2, sy+2, S-4, S/2-2);
      break;
    case COAL:
      ctx.fillStyle = '#222222';
      for (let i = 0; i < 3; i++) { ctx.fillRect(((wx*9+i*11)%(S-8))+sx+2, ((wy*7+i*13)%(S-8))+sy+2, 6, 6); }
      break;
    case COPPER:
      ctx.fillStyle = '#d4884a';
      for (let i = 0; i < 4; i++) {
        const cx = ((wx*7+i*9)%(S-6))+sx+2, cy = ((wy*11+i*7)%(S-6))+sy+2;
        ctx.beginPath(); ctx.arc(cx+3, cy+3, 3, 0, Math.PI*2); ctx.fill();
      }
      break;
    case IRON:
      ctx.fillStyle = '#b8b8c8';
      for (let i = 0; i < 3; i++) { ctx.fillRect(((wx*13+i*7)%(S-8))+sx+3, ((wy*9+i*11)%(S-6))+sy+2, 5, 4); }
      ctx.fillStyle = '#888898'; ctx.fillRect(sx+4, sy+4, 6, 5);
      break;
    case SILVER: {
      const shimmer = Math.sin(t*3+wx+wy)*0.15+0.85;
      ctx.fillStyle = `rgba(220,220,235,${shimmer})`; ctx.fillRect(sx+2, sy+2, S-4, S-4);
      ctx.fillStyle = '#e8e8f0'; ctx.fillRect(sx+6, sy+4, 8, 6); ctx.fillRect(sx+14, sy+14, 10, 8);
      const hx = sx+(Math.sin(t*2+wx)*0.5+0.5)*(S-6)+3;
      ctx.fillStyle = `rgba(255,255,255,${0.3+Math.sin(t*4)*0.2})`; ctx.fillRect(hx, sy+4, 3, 3);
      break;
    }
    case GOLD: {
      const glow = Math.sin(t*2+wx*0.5+wy*0.3)*0.15+0.85;
      ctx.fillStyle = `rgba(255,215,0,${glow})`; ctx.fillRect(sx+2, sy+2, S-4, S-4);
      ctx.fillStyle = '#ffea55'; ctx.fillRect(sx+6, sy+6, 8, 8); ctx.fillRect(sx+16, sy+4, 6, 6);
      ctx.fillStyle = '#cc9900'; ctx.fillRect(sx+4, sy+18, 10, 6);
      ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 6;
      ctx.fillStyle = 'rgba(255,215,0,0.3)'; ctx.fillRect(sx, sy, S, S); ctx.shadowBlur = 0;
      break;
    }
    case DIAMOND: {
      const sparkle = Math.sin(t*5+wx*2+wy)*0.3+0.7;
      ctx.fillStyle = '#004455'; ctx.fillRect(sx, sy, S, S);
      ctx.fillStyle = `rgba(0,255,255,${sparkle})`;
      ctx.beginPath(); ctx.moveTo(sx+S/2, sy+4); ctx.lineTo(sx+S-4, sy+S/2);
      ctx.lineTo(sx+S/2, sy+S-4); ctx.lineTo(sx+4, sy+S/2); ctx.closePath(); ctx.fill();
      ctx.fillStyle = `rgba(200,255,255,${Math.sin(t*8+wx)*0.5+0.5})`;
      ctx.fillRect(sx+8, sy+8, 2, 2); ctx.fillRect(sx+20, sy+14, 2, 2); ctx.fillRect(sx+14, sy+22, 2, 2);
      ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 8;
      ctx.fillRect(sx+S/2-1, sy+S/2-1, 2, 2); ctx.shadowBlur = 0;
      break;
    }
    case EMERALD: {
      const glow = Math.sin(t*3+wx+wy*2)*0.2+0.8;
      ctx.fillStyle = '#1a4a2a'; ctx.fillRect(sx, sy, S, S);
      ctx.fillStyle = `rgba(80,200,120,${glow})`;
      ctx.beginPath(); ctx.moveTo(sx+8,sy+4); ctx.lineTo(sx+24,sy+4); ctx.lineTo(sx+28,sy+16);
      ctx.lineTo(sx+24,sy+28); ctx.lineTo(sx+8,sy+28); ctx.lineTo(sx+4,sy+16); ctx.closePath(); ctx.fill();
      ctx.shadowColor = '#50c878'; ctx.shadowBlur = 8;
      ctx.fillStyle = 'rgba(80,200,120,0.4)'; ctx.fillRect(sx+10, sy+10, 12, 12); ctx.shadowBlur = 0;
      break;
    }
    case BAICRYSTAL: {
      const pulse = Math.sin(t*4+wx+wy)*0.3+0.7;
      ctx.fillStyle = '#2a0040'; ctx.fillRect(sx, sy, S, S);
      ctx.fillStyle = `rgba(255,0,255,${pulse})`; ctx.fillRect(sx+4, sy+4, S-8, S-8);
      ctx.fillStyle = `rgba(255,100,255,${pulse*0.8})`;
      ctx.beginPath(); ctx.moveTo(sx+S/2,sy+2); ctx.lineTo(sx+S-6,sy+S/2);
      ctx.lineTo(sx+S/2,sy+S-2); ctx.lineTo(sx+6,sy+S/2); ctx.closePath(); ctx.fill();
      ctx.fillStyle = `rgba(255,200,255,${pulse*0.6})`; ctx.font = '8px monospace';
      ctx.fillText('B', sx+11, sy+19);
      ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 12;
      ctx.fillStyle = 'rgba(255,0,255,0.3)'; ctx.fillRect(sx, sy, S, S); ctx.shadowBlur = 0;
      break;
    }
    case VOIDORE: {
      const anim = Math.sin(t*2+wx*0.5+wy*0.5), anim2 = Math.cos(t*3+wx+wy);
      ctx.fillStyle = '#0a0018'; ctx.fillRect(sx, sy, S, S);
      ctx.fillStyle = `rgba(100,0,170,${0.5+anim*0.3})`;
      ctx.beginPath(); ctx.arc(sx+S/2+anim*4, sy+S/2+anim2*4, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(180,0,255,${0.4+anim2*0.3})`;
      ctx.beginPath(); ctx.arc(sx+S/2-anim2*3, sy+S/2+anim*3, 6, 0, Math.PI*2); ctx.fill();
      ctx.shadowColor = '#6a00aa'; ctx.shadowBlur = 15;
      ctx.strokeStyle = `rgba(150,0,255,${0.5+anim*0.3})`; ctx.lineWidth = 1.5;
      ctx.strokeRect(sx+2, sy+2, S-4, S-4); ctx.shadowBlur = 0;
      ctx.fillStyle = `rgba(220,150,255,${0.6+anim*0.3})`; ctx.fillRect(sx+13, sy+13, 6, 6);
      break;
    }
    case BEDROCK:
      ctx.fillStyle = '#252525'; ctx.fillRect(sx+2, sy, S-4, S/2);
      ctx.fillStyle = '#111111'; ctx.fillRect(sx, sy+S/2, S/2, S/2);
      ctx.fillRect(sx+S/2+2, sy+S/2, S/2-2, S/2);
      ctx.strokeStyle = '#0a0a0a'; ctx.lineWidth = 0.5; ctx.strokeRect(sx, sy, S, S);
      break;
    case LAVA: {
      const la = Math.sin(t*2+wx*0.3+wy*0.5), la2 = Math.cos(t*1.5+wx*0.7);
      ctx.fillStyle = '#cc2200'; ctx.fillRect(sx, sy, S, S);
      ctx.fillStyle = `rgba(255,100,0,${0.6+la*0.3})`; ctx.fillRect(sx+2, sy+2, S-4, S-4);
      ctx.fillStyle = `rgba(255,200,50,${0.4+la2*0.3})`;
      ctx.beginPath(); ctx.arc(sx+10+la*4, sy+10+la2*3, 6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(sx+22-la2*3, sy+20+la*2, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(255,255,100,${0.3+la*0.2})`; ctx.fillRect(sx+8, sy+14, 8, 4);
      ctx.shadowColor = '#ff4400'; ctx.shadowBlur = 10;
      ctx.fillStyle = 'rgba(255,68,0,0.2)'; ctx.fillRect(sx, sy, S, S); ctx.shadowBlur = 0;
      break;
    }
  }

  if (tile !== AIR && tile !== CAVE && tile !== BEDROCK && tile !== LAVA) {
    const maxHP = BLOCK_DEF[tile].hardness, curHP = getHP(wx, wy);
    if (curHP < maxHP && maxHP > 0) {
      const dmgRatio = 1 - (curHP / maxHP);
      ctx.strokeStyle = `rgba(0,0,0,${0.3+dmgRatio*0.5})`; ctx.lineWidth = 1+dmgRatio*2;
      const inset = 4;
      ctx.beginPath();
      ctx.moveTo(sx+inset, sy+inset); ctx.lineTo(sx+S-inset, sy+S-inset);
      ctx.moveTo(sx+S-inset, sy+inset); ctx.lineTo(sx+inset, sy+S-inset);
      if (dmgRatio > 0.3) { ctx.moveTo(sx+S/2, sy+inset); ctx.lineTo(sx+S/2, sy+S-inset); }
      if (dmgRatio > 0.6) { ctx.moveTo(sx+inset, sy+S/2); ctx.lineTo(sx+S-inset, sy+S/2); }
      ctx.stroke();
      ctx.fillStyle = `rgba(255,255,255,${dmgRatio*0.15})`; ctx.fillRect(sx, sy, S, S);
    }
  }

  ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 0.5; ctx.strokeRect(sx, sy, S, S);
}

function drawPlayer(px, py) {
  const S = TILE_SIZE, t = animTime * 0.003;
  ctx.fillStyle = '#00ffc8'; ctx.fillRect(px+4, py+4, S-8, S-8);
  ctx.strokeStyle = '#00ffaa'; ctx.lineWidth = 2; ctx.strokeRect(px+4, py+4, S-8, S-8);
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(px+9, py+10, 4, 4); ctx.fillRect(px+19, py+10, 4, 4);
  ctx.fillRect(px+11, py+19, 10, 2);
  ctx.shadowColor = '#00ffc8'; ctx.shadowBlur = 12;
  ctx.fillStyle = 'rgba(0,255,200,0.15)'; ctx.fillRect(px-4, py-4, S+8, S+8); ctx.shadowBlur = 0;
  ctx.fillStyle = '#00ffc8'; ctx.fillRect(px+S/2-1, py, 2, 5);
  ctx.fillStyle = Math.sin(t*4) > 0.5 ? '#ff0066' : '#880033';
  ctx.fillRect(px+S/2-2, py-1, 4, 3);
}

function updateHUD() {
  const depth = Math.max(0, Math.floor(player.y - SURFACE_Y));
  document.getElementById('depth').textContent = `Depth: ${depth}m`;
  document.getElementById('score').textContent = `\u26CF ${player.score.toLocaleString()} ORE`;
  const hpPct = Math.max(0, player.hp / player.maxHp) * 100;
  document.getElementById('healthBarInner').style.width = hpPct + '%';
  document.getElementById('healthText').textContent = `${Math.max(0, player.hp)} / ${player.maxHp}`;

  const invEl = document.getElementById('inventory');
  let html = '<div style="color:#00ffc8;margin-bottom:4px;font-weight:bold;font-size:10px;">INVENTORY</div>';
  const oreOrder = [DIRT, STONE, COAL, COPPER, IRON, SILVER, GOLD, DIAMOND, EMERALD, BAICRYSTAL, VOIDORE];
  for (const id of oreOrder) {
    const count = player.inventory[id] || 0;
    if (count === 0) continue;
    const def = BLOCK_DEF[id];
    html += `<div class="inv-row"><span class="inv-icon" style="background:${def.color};"></span>${def.name}: ${count}</div>`;
  }
  invEl.innerHTML = html;
}

window.addEventListener('DOMContentLoaded', init);
document.addEventListener('touchstart', function(e) {
  if (gameState === 'start') { e.preventDefault(); startGame(); }
}, {passive: false, once: true});
</script>
</body>
</html>