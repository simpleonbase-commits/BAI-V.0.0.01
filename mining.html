<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BAI Mining Terminal v2</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  background: #0a0a0f;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  color: #00ffc8;
  user-select: none;
  -webkit-user-select: none;
}
#gameContainer {
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  position: relative;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  image-rendering: pixelated;
}
#hud {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 10;
}
#title {
  position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
  font-size: 14px; font-weight: bold; color: #00ffc8;
  text-shadow: 0 0 10px #00ffc8, 0 0 20px #00ffc888;
  letter-spacing: 3px; white-space: nowrap;
}
#depth {
  position: absolute; top: 32px; left: 12px;
  font-size: 14px; color: #aaffcc;
  text-shadow: 0 0 5px #00ffc866;
}
#score {
  position: absolute; top: 50px; left: 12px;
  font-size: 14px; font-weight: bold; color: #ffd700;
  text-shadow: 0 0 8px #ffd70088;
}
#pickaxeDisplay {
  position: absolute; top: 68px; left: 12px;
  font-size: 11px; color: #88ccff;
}
#inventory {
  position: absolute; top: 90px; left: 8px;
  font-size: 11px; line-height: 1.6; color: #ccc;
  background: rgba(0,0,0,0.55); padding: 6px 10px;
  border: 1px solid #00ffc833; border-radius: 4px;
  max-height: 40vh; overflow-y: auto;
}
.inv-row { display: flex; align-items: center; gap: 5px; }
.inv-icon { width: 10px; height: 10px; display: inline-block; border-radius: 2px; flex-shrink: 0; }
/* Health + Stamina bars */
#barsContainer {
  position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
  display: flex; flex-direction: column; align-items: center; gap: 4px;
  width: min(300px, 60vw);
}
#staminaBarOuter {
  width: 100%; height: 12px;
  background: #1a1a1a; border: 1px solid #3355ff55; border-radius: 6px;
  overflow: hidden; position: relative;
}
#staminaBarInner {
  height: 100%; width: 100%;
  background: linear-gradient(90deg, #2255ff, #55aaff);
  border-radius: 6px; transition: width 0.15s;
}
#lowEnergyText {
  position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
  font-size: 8px; color: #ffaa00; font-weight: bold;
  display: none;
}
@keyframes flicker { 0%,100%{opacity:1} 50%{opacity:0.2} }
.lowEnergyFlicker { animation: flicker 0.4s infinite; display: flex !important; }
#energyLabel {
  font-size: 9px; color: #5599ff; align-self: flex-start;
}
#healthBarOuter {
  width: 100%; height: 14px;
  background: #1a1a1a; border: 1px solid #00ffc855; border-radius: 7px;
  overflow: hidden;
}
#healthBarInner {
  height: 100%; width: 100%;
  background: linear-gradient(90deg, #ff3333, #ffaa00, #33ff66);
  border-radius: 7px; transition: width 0.2s;
}
#healthText {
  font-size: 9px; color: #aaffcc; align-self: flex-start;
}
/* Wallet section */
#walletSection {
  position: absolute; top: 8px; right: 12px;
  display: flex; flex-direction: column; align-items: flex-end; gap: 4px;
  pointer-events: auto;
}
#connectWalletBtn {
  background: rgba(0,255,200,0.1); border: 1px solid #00ffc855;
  color: #00ffc8; font-family: 'Courier New', monospace; font-size: 10px;
  padding: 4px 10px; border-radius: 4px; cursor: pointer;
  pointer-events: auto;
}
#connectWalletBtn:hover { background: rgba(0,255,200,0.25); }
#walletInfo { display: none; flex-direction: column; align-items: flex-end; gap: 3px; }
#walletAddr { font-size: 9px; color: #88ccaa; }
#redeemBtn {
  background: rgba(255,215,0,0.1); border: 1px solid #ffd70055;
  color: #ffd700; font-family: 'Courier New', monospace; font-size: 10px;
  padding: 4px 10px; border-radius: 4px; cursor: pointer;
  pointer-events: auto;
}
#redeemBtn:hover { background: rgba(255,215,0,0.25); }
/* Event banner */
#eventBanner {
  position: absolute; top: 34px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.8); border: 1px solid #ffd700;
  color: #ffd700; font-size: 16px; font-weight: bold;
  padding: 8px 24px; border-radius: 6px;
  letter-spacing: 2px; white-space: nowrap;
  transition: opacity 0.5s;
  opacity: 0; pointer-events: none;
  text-shadow: 0 0 12px #ffd700;
}
/* Mission flash */
#missionFlash {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
  font-size: 28px; font-weight: bold; color: #ffd700;
  text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd70066;
  letter-spacing: 4px;
  opacity: 0; transition: opacity 0.3s;
  pointer-events: none;
}
/* Missions Button */
#missionsBtn {
  position: absolute; bottom: 80px; right: 8px;
  background: rgba(0,0,0,0.75); border: 1px solid #00ffc8;
  color: #00ffc8; font-family: monospace; font-size: 10px;
  font-weight: bold; letter-spacing: 2px; padding: 6px 12px;
  border-radius: 6px; cursor: pointer; pointer-events: auto;
  transition: background 0.2s; z-index: 60;
}
#missionsBtn:hover { background: rgba(0,255,200,0.15); }

/* Missions Overlay */
#missionsOverlay {
  display: none; position: absolute; inset: 0;
  background: rgba(0,0,0,0.75);
  align-items: center; justify-content: center;
  z-index: 70; pointer-events: auto;
}
#missionsOverlay.open { display: flex; }
#missionsBox {
  background: #0a0a1a; border: 1px solid #00ffc8;
  border-radius: 10px; padding: 24px 32px; min-width: 300px;
  max-width: 400px; text-align: center;
}
#missionTitle {
  color: #00ffc8; font-weight: bold; font-size: 14px;
  margin-bottom: 16px; letter-spacing: 3px;
}
.mission-item {
  display: flex; align-items: center; gap: 10px;
  margin-bottom: 10px; color: #aaa; font-size: 11px;
  text-align: left;
}
.mission-item.done { color: #ffd700; }
.mission-check { width: 14px; height: 14px; border: 1px solid #555; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 10px; flex-shrink: 0; }
.mission-item.done .mission-check { border-color: #ffd700; background: #ffd700; color: #000; }
#closeMissionsBtn {
  margin-top: 16px; background: transparent; border: 1px solid #00ffc8;
  color: #00ffc8; font-family: monospace; font-size: 11px;
  padding: 6px 20px; border-radius: 6px; cursor: pointer;
  letter-spacing: 2px;
}
#closeMissionsBtn:hover { background: rgba(0,255,200,0.1); }
/* Upgrade overlay */
#upgradeOverlay {
  position: absolute; inset: 0;
  background: rgba(0,0,0,0.88);
  display: none; align-items: center; justify-content: center;
  z-index: 60; pointer-events: auto;
}
#upgradeBox {
  border: 1px solid #00ffc8; border-radius: 8px;
  padding: 24px 32px; min-width: 280px;
  background: #0a0a1a;
}
#upgradeBox h2 { color: #00ffc8; font-size: 18px; letter-spacing: 3px; margin-bottom: 16px; text-align: center; }
.upgrade-tier {
  border: 1px solid #333; border-radius: 4px; padding: 10px;
  margin-bottom: 8px; cursor: pointer;
}
.upgrade-tier.current { border-color: #00ffc8; background: rgba(0,255,200,0.08); }
.upgrade-tier.affordable { border-color: #ffd70055; }
.upgrade-tier:hover:not(.current) { background: rgba(255,255,255,0.05); }
.upgrade-tier h3 { font-size: 13px; color: #fff; margin-bottom: 4px; }
.upgrade-tier p { font-size: 10px; color: #888; }
.upgrade-tier .cost { font-size: 11px; color: #ffd700; margin-top: 4px; }
#upgradeClose {
  display: block; margin: 16px auto 0;
  background: transparent; border: 1px solid #555;
  color: #aaa; font-family: 'Courier New', monospace; font-size: 12px;
  padding: 6px 20px; border-radius: 4px; cursor: pointer;
}
#upgradeClose:hover { border-color: #00ffc8; color: #00ffc8; }
/* Ore breakdown in redeem modal */
.redeem-breakdown {
  background: rgba(0,0,0,0.4);
  border: 1px solid #333;
  border-radius: 4px;
  padding: 8px;
  max-height: 160px;
  overflow-y: auto;
}
.redeem-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 3px 0;
  font-size: 11px;
  border-bottom: 1px solid #222;
}
.redeem-row:last-child { border-bottom: none; }
.redeem-ore-dot {
  width: 10px; height: 10px;
  border-radius: 2px;
  flex-shrink: 0;
}
.redeem-ore-name { color: #ccc; flex: 1; }
.redeem-ore-count { color: #888; width: 35px; text-align: right; }
.redeem-ore-rate { color: #666; width: 45px; text-align: right; }
.redeem-ore-val { color: #ffd700; width: 70px; text-align: right; font-weight: bold; }

/* Redeem modal */
#redeemModal {
  position: absolute; inset: 0;
  background: rgba(0,0,0,0.9);
  display: none; align-items: center; justify-content: center;
  z-index: 70; pointer-events: auto;
}
#redeemBox {
  border: 1px solid #ffd700; border-radius: 8px;
  padding: 24px 32px; max-width: 460px; width: 90%; text-align: center;
  background: #0a0a0a;
}
#redeemBox h2 { color: #ffd700; font-size: 18px; margin-bottom: 12px; letter-spacing: 2px; }
#redeemBox p { color: #aaa; font-size: 12px; line-height: 1.6; margin-bottom: 8px; }
#redeemClose {
  margin-top: 16px;
  background: transparent; border: 1px solid #ffd700;
  color: #ffd700; font-family: 'Courier New', monospace; font-size: 12px;
  padding: 6px 20px; border-radius: 4px; cursor: pointer;
}
/* Start screen */
#startScreen {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: #0a0a0f;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100;
}
#startScreen h1 {
  font-size: clamp(24px, 5vw, 48px); color: #00ffc8;
  text-shadow: 0 0 20px #00ffc8, 0 0 40px #00ffc866, 0 0 80px #00ffc833;
  letter-spacing: 6px; margin-bottom: 20px; text-align: center;
}
#startScreen .subtitle {
  font-size: clamp(11px, 2vw, 16px); color: #88ccaa; margin-bottom: 8px; text-align: center; padding: 0 20px;
}
#startScreen .prompt {
  font-size: clamp(14px, 2.5vw, 20px); color: #ffd700;
  margin-top: 30px; animation: blink 1.2s infinite;
}
#startBest { font-size: 13px; color: #ffd700; margin-top: 10px; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
#startCanvas {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
}
/* Death overlay */
#deathOverlay {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(180,0,0,0.25);
  display: none; align-items: center; justify-content: center;
  flex-direction: column; z-index: 50; pointer-events: auto;
}
#deathOverlay h2 { font-size: 36px; color: #ff4444; text-shadow: 0 0 20px #ff0000; margin-bottom: 10px; }
#deathOverlay .death-score { color: #ffd700; font-size: 18px; margin-bottom: 4px; }
#deathOverlay .death-best { color: #ffaa88; font-size: 14px; margin-bottom: 4px; }
#deathOverlay .death-new { color: #00ffc8; font-size: 16px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 10px #00ffc8; display: none; }
#deathOverlay .death-hint { color: #888; font-size: 12px; margin-top: 10px; }
#deathOverlay .death-penalty { color: #ffaa88; font-size: 11px; }
#deathClaimBtn {
  margin-top: 14px;
  background: rgba(255,215,0,0.15); border: 1px solid #ffd700;
  color: #ffd700; font-family: 'Courier New', monospace; font-size: 13px;
  padding: 8px 20px; border-radius: 4px; cursor: pointer;
  display: none;
}
#deathRestartBtn {
  margin-top: 10px;
  background: rgba(0,255,200,0.1); border: 1px solid #00ffc8;
  color: #00ffc8; font-family: 'Courier New', monospace; font-size: 13px;
  padding: 8px 20px; border-radius: 4px; cursor: pointer;
}
/* Ore rush tint */
#oreRushOverlay {
  position: absolute; inset: 0;
  background: rgba(255,200,0,0.07);
  pointer-events: none; z-index: 12;
  display: none;
}
/* Rare flash */
#rareFlash {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none; z-index: 15;
  background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
  opacity: 0; transition: opacity 0.1s;
}
/* Mobile controls */
#mobileControls {
  display: none;
  position: absolute; bottom: 50px; right: 10px;
  z-index: 20; pointer-events: auto;
}
.mBtn {
  width: 48px; height: 48px; background: rgba(0,255,200,0.15);
  border: 1px solid #00ffc855; border-radius: 8px;
  color: #00ffc8; font-size: 20px; display: flex;
  align-items: center; justify-content: center;
  pointer-events: auto; touch-action: none;
}
.mBtn:active { background: rgba(0,255,200,0.4); }
#mobileGrid {
  display: grid;
  grid-template-columns: 48px 48px 48px;
  grid-template-rows: 48px 48px 48px;
  gap: 4px;
}
@media (pointer: coarse) {
  #mobileControls { display: block; }
}
/* Minimap hint */
#minimapHint {
  position: absolute; bottom: 8px; right: 8px;
  font-size: 8px; color: #00ffc844;
  pointer-events: none;
}
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="startCanvas"></canvas>
  <div id="startScreen">
    <h1>BAI MINING<br>TERMINAL</h1>
    <div class="subtitle">WASD / Arrow Keys to move &amp; mine</div>
    <div class="subtitle">Go deeper for rarer ores &bull; Avoid lava</div>
    <div class="subtitle" style="color:#88aacc">U = Upgrades &bull; M = Minimap &bull; ESC = Close</div>
    <div id="startBest" style="display:none"></div>
    <div class="prompt">[ PRESS ENTER OR TAP TO BEGIN ]</div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="hud" style="display:none;">
    <div id="title">BAI MINING TERMINAL v2</div>
    <div id="depth">Depth: 0m</div>
    <div id="score">&#x26CF; 0 ORE</div>
    <div id="pickaxeDisplay">&#x26CF; BASIC</div>
    <div id="inventory"></div>
    <div id="barsContainer">
      <div id="energyLabel">ENERGY: 100/100</div>
      <div id="staminaBarOuter">
        <div id="staminaBarInner"></div>
        <div id="lowEnergyText">&#x26A1; LOW ENERGY</div>
      </div>
      <div id="healthText">HP: 100/100</div>
      <div id="healthBarOuter"><div id="healthBarInner"></div></div>
    </div>
    <div id="walletSection">
      <button id="connectWalletBtn">CONNECT WALLET</button>
      <div id="walletInfo">
        <span id="walletAddr"></span>
        <button id="redeemBtn">&#x1F48E; REDEEM $GEM</button>
      </div>
    </div>
    <div id="eventBanner"></div>
    <div id="missionFlash">MISSION COMPLETE!</div>
    <button id="missionsBtn" onclick="toggleMissions()">&#x2605; MISSIONS</button>
    <div id="missionsOverlay" onclick="if(event.target===this)toggleMissions()">
      <div id="missionsBox">
        <div id="missionTitle">&#x2605; DAILY MISSIONS</div>
        <div id="missionList"></div>
        <button id="closeMissionsBtn" onclick="toggleMissions()">CLOSE</button>
      </div>
    </div>
    <div id="oreRushOverlay"></div>
    <div id="rareFlash"></div>
    <div id="minimapHint">[M] MINIMAP</div>
  </div>
  <div id="deathOverlay">
    <h2>SYSTEM FAILURE</h2>
    <div class="death-score" id="deathScore"></div>
    <div class="death-best" id="deathBest"></div>
    <div class="death-new" id="deathNew">&#x2605; NEW HIGH SCORE! &#x2605;</div>
    <div class="death-penalty">-10% ORE penalty applied</div>
    <button id="deathClaimBtn">&#x1F48E; Claim $GEM</button>
    <button id="deathRestartBtn">RESTART</button>
    <div class="death-hint">Press ENTER or click RESTART</div>
  </div>
  <div id="upgradeOverlay">
    <div id="upgradeBox">
      <h2>&#x26CF; PICKAXE UPGRADES</h2>
      <div id="upgradeTiers"></div>
      <button id="upgradeClose">[ ESC / CLOSE ]</button>
    </div>
  </div>
  <div id="redeemModal">
    <div id="redeemBox">
      <h2>&#x1F48E; REDEMPTION READY</h2>
      <p id="redeemMsg"></p>
      <p style="color:#555;font-size:10px;">Full on-chain redemption activates when the game server is live. Your score is saved.</p>
      <button id="redeemClose">[ CLOSE ]</button>
    </div>
  </div>
  <div id="mobileControls">
    <div id="mobileGrid">
      <div></div>
      <div class="mBtn" data-dir="up">&#x25B2;</div>
      <div></div>
      <div class="mBtn" data-dir="left">&#x25C4;</div>
      <div class="mBtn" data-dir="down">&#x25BC;</div>
      <div class="mBtn" data-dir="right">&#x25BA;</div>
    </div>
  </div>
</div>

<script>
"use strict";

// === CONSTANTS ===
const TILE_SIZE = 32;
const WORLD_W = 200;
const WORLD_H = 200;
const SURFACE_Y = 10;
const GRAVITY_INTERVAL = 120;
const LAVA_TICK = 500;

const AIR=0, GRASS=1, DIRT=2, STONE=3, COAL=4, COPPER=5, IRON=6,
      SILVER=7, GOLD=8, DIAMOND=9, EMERALD=10, BAICRYSTAL=11,
      VOIDORE=12, BEDROCK=13, LAVA=14, CAVE=15;

const REWARDS_CONTRACT = "0x0000000000000000000000000000000000000000";
const GEM_TOKEN = "0xd3776969966b340d72d75731ef890a3bc9f21ba3";
const BASE_CHAIN_ID = 8453;

// === GEM REDEMPTION RATES (per ore block mined) ===
const GEM_RATES = {
  4:  0.05,   // Coal
  5:  0.10,   // Copper
  6:  0.25,   // Iron
  7:  0.75,   // Silver
  8:  2.00,   // Gold
  9:  5.00,   // Diamond
  10: 10.00,  // Emerald
  11: 25.00,  // BAI Crystal
  12: 50.00,  // Void Ore
};
const MIN_REDEEM_GEM = 5;

// Calculate total GEM value from player inventory
function calculateGemValue() {
  let total = 0;
  for (const [tileId, rate] of Object.entries(GEM_RATES)) {
    const count = player.inventory[parseInt(tileId)] || 0;
    total += count * rate;
  }
  return total;
}

// Build ore breakdown HTML for redeem modal
function buildOreBreakdownHTML() {
  const oreNames = {4:'Coal',5:'Copper',6:'Iron',7:'Silver',8:'Gold',9:'Diamond',10:'Emerald',11:'BAI Crystal',12:'Void Ore'};
  const oreColors = {4:'#444',5:'#b87333',6:'#a0a0b0',7:'#c0c0d0',8:'#ffd700',9:'#88eeff',10:'#50e050',11:'#00ffc8',12:'#cc00ff'};
  let rows = '';
  let hasOre = false;
  for (const [tileId, rate] of Object.entries(GEM_RATES)) {
    const count = player.inventory[parseInt(tileId)] || 0;
    if (count === 0) continue;
    hasOre = true;
    const gemVal = (count * rate).toFixed(2);
    rows += `<div class="redeem-row">
      <span class="redeem-ore-dot" style="background:${oreColors[tileId]};"></span>
      <span class="redeem-ore-name">${oreNames[tileId]}</span>
      <span class="redeem-ore-count">x${count}</span>
      <span class="redeem-ore-rate">@ ${rate}</span>
      <span class="redeem-ore-val">= ${gemVal} $GEM</span>
    </div>`;
  }
  if (!hasOre) rows = '<div style="color:#555;font-size:11px;text-align:center;padding:8px 0;">No valuable ore mined yet.</div>';
  return rows;
}

const REWARDS_ABI = [
  {"inputs":[{"internalType":"uint256[]","name":"oreIds","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"sig","type":"bytes"}],"name":"redeemOres","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"oreRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
];

const BLOCK_DEF = {
  [AIR]:        {name:'Air',        color:'transparent', hardness:0,        value:0,    depth:[0,0]},
  [GRASS]:      {name:'Grass',      color:'#4a7c3f',     hardness:1,        value:0,    depth:[0,1]},
  [DIRT]:       {name:'Dirt',       color:'#8B6914',     hardness:1,        value:1,    depth:[0,15]},
  [STONE]:      {name:'Stone',      color:'#808080',     hardness:2,        value:2,    depth:[5,200]},
  [COAL]:       {name:'Coal',       color:'#333333',     hardness:2,        value:5,    depth:[10,50]},
  [COPPER]:     {name:'Copper',     color:'#b87333',     hardness:3,        value:10,   depth:[15,60]},
  [IRON]:       {name:'Iron',       color:'#a0a0b0',     hardness:3,        value:20,   depth:[25,80]},
  [SILVER]:     {name:'Silver',     color:'#c0c0c0',     hardness:4,        value:40,   depth:[35,100]},
  [GOLD]:       {name:'Gold',       color:'#ffd700',     hardness:4,        value:80,   depth:[50,120]},
  [DIAMOND]:    {name:'Diamond',    color:'#00ffff',     hardness:5,        value:200,  depth:[70,150]},
  [EMERALD]:    {name:'Emerald',    color:'#50c878',     hardness:5,        value:300,  depth:[80,160]},
  [BAICRYSTAL]: {name:'BAI Crystal',color:'#ff00ff',     hardness:6,        value:500,  depth:[100,180]},
  [VOIDORE]:    {name:'Void Ore',   color:'#6a00aa',     hardness:8,        value:1000, depth:[150,200]},
  [BEDROCK]:    {name:'Bedrock',    color:'#1a1a1a',     hardness:Infinity, value:0,    depth:[195,200]},
  [LAVA]:       {name:'Lava',       color:'#ff4400',     hardness:Infinity, value:0,    depth:[120,190]},
  [CAVE]:       {name:'Cave',       color:'transparent', hardness:0,        value:0,    depth:[0,200]},
};

// Stamina cost per ore type
const STAMINA_COST = {
  [GRASS]:1, [DIRT]:1, [STONE]:2, [COAL]:3, [COPPER]:4, [IRON]:5,
  [SILVER]:6, [GOLD]:7, [DIAMOND]:8, [EMERALD]:9, [BAICRYSTAL]:10, [VOIDORE]:12
};

// Pickaxe tiers
const PICKAXE_TIERS = [
  {name:'BASIC',     cost:0,    cooldown:100, power:1},
  {name:'STEEL',     cost:500,  cooldown:80,  power:2},
  {name:'VOID DRILL',cost:5000, cooldown:55,  power:3},
];

// Depth zones
const DEPTH_ZONES = [
  {minDepth:0,   name:'SURFACE',         color:'#88ffaa'},
  {minDepth:15,  name:'UNDERGROUND',     color:'#88ccaa'},
  {minDepth:50,  name:'DEEP ROCK',       color:'#8899cc'},
  {minDepth:100, name:'DEEP CAVERNS',    color:'#aa88cc'},
  {minDepth:150, name:'THE VOID',        color:'#cc44ff'},
];

const HIGH_SCORE_KEY = 'bai_mining_highscore_v2';

// === RNG / NOISE ===
function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;let t=Math.imul(a^a>>>15,1|a);t^=t+Math.imul(t^t>>>7,61|t);return((t^t>>>14)>>>0)/4294967296;};}
let rng;

const noiseP = new Uint8Array(512);
function initNoise(seed){
  const r=mulberry32(seed);
  for(let i=0;i<256;i++) noiseP[i]=i;
  for(let i=255;i>0;i--){const j=(r()*i)|0;[noiseP[i],noiseP[j]]=[noiseP[j],noiseP[i]];}
  for(let i=0;i<256;i++) noiseP[i+256]=noiseP[i];
}
function fade(t){return t*t*t*(t*(t*6-15)+10);}
function lerp(a,b,t){return a+t*(b-a);}
function grad(h,x,y){const v=h&3;return((v&1)?-x:x)+((v&2)?-y:y);}
function noise2D(x,y){
  const X=Math.floor(x)&255,Y=Math.floor(y)&255;
  const xf=x-Math.floor(x),yf=y-Math.floor(y);
  const u=fade(xf),v=fade(yf);
  const aa=noiseP[noiseP[X]+Y],ab=noiseP[noiseP[X]+Y+1];
  const ba=noiseP[noiseP[X+1]+Y],bb=noiseP[noiseP[X+1]+Y+1];
  return lerp(lerp(grad(aa,xf,yf),grad(ba,xf-1,yf),u),lerp(grad(ab,xf,yf-1),grad(bb,xf-1,yf-1),u),v);
}
function octaveNoise(x,y,oct,pers){
  let total=0,freq=1,amp=1,maxV=0;
  for(let i=0;i<oct;i++){total+=noise2D(x*freq,y*freq)*amp;maxV+=amp;amp*=pers;freq*=2;}
  return total/maxV;
}

// === WORLD ===
let world, worldHP, explored;

function generateWorld(seed){
  rng=mulberry32(seed);
  initNoise(seed);
  world=new Uint8Array(WORLD_W*WORLD_H);
  worldHP=new Float32Array(WORLD_W*WORLD_H);
  explored=new Uint8Array(WORLD_W*WORLD_H);
  world.fill(AIR);

  const surfaceHeight=new Float32Array(WORLD_W);
  for(let x=0;x<WORLD_W;x++){
    surfaceHeight[x]=SURFACE_Y+Math.round(octaveNoise(x*0.05,0,3,0.5)*3);
  }

  for(let x=0;x<WORLD_W;x++){
    const sh=surfaceHeight[x];
    for(let y=0;y<WORLD_H;y++){
      if(y<sh-1){setTile(x,y,AIR);continue;}
      if(y===sh-1||y===sh){setTile(x,y,GRASS);continue;}
      const depth=y-sh;
      if(depth<=15){setTile(x,y,DIRT);}
      else{setTile(x,y,STONE);}
    }
  }

  for(let x=0;x<WORLD_W;x++){
    const sh=surfaceHeight[x];
    for(let y=sh+5;y<WORLD_H-5;y++){
      const caveN=octaveNoise(x*0.08,y*0.06,3,0.5);
      const caveN2=octaveNoise(x*0.12+500,y*0.1+500,2,0.5);
      if(caveN>0.35&&caveN2>0.1) setTile(x,y,CAVE);
      const bigCave=octaveNoise(x*0.03+1000,y*0.03+1000,2,0.5);
      if(bigCave>0.42) setTile(x,y,CAVE);
    }
  }

  const oreTypes=[COAL,COPPER,IRON,SILVER,GOLD,DIAMOND,EMERALD,BAICRYSTAL,VOIDORE];
  const oreChance={[COAL]:0.06,[COPPER]:0.04,[IRON]:0.03,[SILVER]:0.02,[GOLD]:0.015,[DIAMOND]:0.008,[EMERALD]:0.006,[BAICRYSTAL]:0.004,[VOIDORE]:0.002};

  for(const ore of oreTypes){
    const def=BLOCK_DEF[ore];
    const[dMin,dMax]=def.depth;
    const chance=oreChance[ore];
    for(let x=1;x<WORLD_W-1;x++){
      const sh=surfaceHeight[x];
      for(let y=sh+dMin;y<Math.min(sh+dMax,WORLD_H-1);y++){
        if(getTile(x,y)!==STONE&&getTile(x,y)!==DIRT) continue;
        const n=octaveNoise(x*0.15+ore*100,y*0.15+ore*100,2,0.5);
        if(n>0.3&&rng()<chance){
          const veinSize=2+Math.floor(rng()*4);
          placeVein(x,y,ore,veinSize);
        }
      }
    }
  }

  for(let x=0;x<WORLD_W;x++){
    for(let y=WORLD_H-6;y<WORLD_H;y++){
      const chance=(y-(WORLD_H-6))/5;
      if(rng()<chance||y>=WORLD_H-2) setTile(x,y,BEDROCK);
    }
  }

  for(let x=0;x<WORLD_W;x++){
    const sh=surfaceHeight[x];
    for(let y=sh+120;y<WORLD_H-8;y++){
      if(getTile(x,y)===CAVE){
        const lavaN=octaveNoise(x*0.1+2000,y*0.1+2000,2,0.5);
        if(lavaN>0.3&&rng()<0.15) setTile(x,y,LAVA);
      }
    }
  }

  for(let i=0;i<WORLD_W*WORLD_H;i++){
    worldHP[i]=BLOCK_DEF[world[i]].hardness;
  }
}

function placeVein(cx,cy,ore,size){
  const dirs=[[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
  let placed=0;
  for(let i=0;i<dirs.length&&placed<size;i++){
    const nx=cx+dirs[i][0],ny=cy+dirs[i][1];
    if(nx<0||nx>=WORLD_W||ny<0||ny>=WORLD_H) continue;
    const t=getTile(nx,ny);
    if(t===STONE||t===DIRT){setTile(nx,ny,ore);placed++;}
  }
}

function getTile(x,y){return(x>=0&&x<WORLD_W&&y>=0&&y<WORLD_H)?world[y*WORLD_W+x]:BEDROCK;}
function setTile(x,y,t){if(x>=0&&x<WORLD_W&&y>=0&&y<WORLD_H) world[y*WORLD_W+x]=t;}
function getHP(x,y){return(x>=0&&x<WORLD_W&&y>=0&&y<WORLD_H)?worldHP[y*WORLD_W+x]:Infinity;}
function setHP(x,y,v){if(x>=0&&x<WORLD_W&&y>=0&&y<WORLD_H) worldHP[y*WORLD_W+x]=v;}

// === AUDIO ENGINE ===
let audioCtx=null;
function getAudio(){
  if(!audioCtx){
    try{ audioCtx=new(window.AudioContext||window.webkitAudioContext)(); }catch(e){}
  }
  return audioCtx;
}
function playMineSound(hardness){
  const ctx=getAudio(); if(!ctx) return;
  const now=ctx.currentTime;
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type='sawtooth';
  const baseFreq=60+hardness*25;
  osc.frequency.setValueAtTime(baseFreq*1.5,now);
  osc.frequency.exponentialRampToValueAtTime(baseFreq*0.5,now+0.08);
  gain.gain.setValueAtTime(0.25,now);
  gain.gain.exponentialRampToValueAtTime(0.001,now+0.1);
  osc.start(now); osc.stop(now+0.12);
}
function playRareOreSound(){
  const ctx=getAudio(); if(!ctx) return;
  const notes=[330,440,554,659,880];
  notes.forEach((freq,i)=>{
    const now=ctx.currentTime+i*0.1;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type='sine';
    osc.frequency.value=freq;
    gain.gain.setValueAtTime(0.25,now);
    gain.gain.exponentialRampToValueAtTime(0.001,now+0.2);
    osc.start(now); osc.stop(now+0.22);
  });
}
function playDeathSound(){
  const ctx=getAudio(); if(!ctx) return;
  const now=ctx.currentTime;
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type='sawtooth';
  osc.frequency.setValueAtTime(400,now);
  osc.frequency.exponentialRampToValueAtTime(40,now+1.0);
  gain.gain.setValueAtTime(0.5,now);
  gain.gain.exponentialRampToValueAtTime(0.001,now+1.0);
  osc.start(now); osc.stop(now+1.1);
}
function playMissionCompleteSound(){
  const ctx=getAudio(); if(!ctx) return;
  const notes=[523,659,784];
  notes.forEach((freq,i)=>{
    const now=ctx.currentTime+i*0.18;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type='square';
    osc.frequency.value=freq;
    gain.gain.setValueAtTime(0.25,now);
    gain.gain.exponentialRampToValueAtTime(0.001,now+0.35);
    osc.start(now); osc.stop(now+0.38);
  });
}
function playOreRushSound(){
  const ctx=getAudio(); if(!ctx) return;
  const now=ctx.currentTime;
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type='sawtooth';
  osc.frequency.setValueAtTime(150,now);
  osc.frequency.exponentialRampToValueAtTime(900,now+0.6);
  gain.gain.setValueAtTime(0.4,now);
  gain.gain.exponentialRampToValueAtTime(0.001,now+0.65);
  osc.start(now); osc.stop(now+0.7);
}
function playEnergySurgeSound(){
  const ctx=getAudio(); if(!ctx) return;
  const now=ctx.currentTime;
  [220,330,440,660].forEach((freq,i)=>{
    const t=now+i*0.08;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type='sine'; osc.frequency.value=freq;
    gain.gain.setValueAtTime(0.3,t);
    gain.gain.exponentialRampToValueAtTime(0.001,t+0.2);
    osc.start(t); osc.stop(t+0.22);
  });
}

// === PLAYER STATE ===
let player={
  x:100,y:5,
  hp:100,maxHp:100,
  stamina:100,maxStamina:100,
  score:0,
  inventory:{},
  dead:false,respawnTimer:0,
  invincible:false,
  pickaxeTier:0,
  totalMined:0,
  deaths:0,
  maxDepth:0,
};

// === GAME STATE ===
let gameState='start';
let canvas,ctx;
let camX=0,camY=0,targetCamX=0,targetCamY=0;
let lastGravity=0,lastLavaTick=0,lastMoveTime=0;
let keysDown={};
let animTime=0;
let screenW,screenH;
let shakeAmount=0,shakeX=0,shakeY=0;
let showMinimap=true;

// Combo
let comboCount=0;
let lastMineTime2=0;
const COMBO_TIMEOUT=800;
const COMBO_MULT=[1,1.5,2,2.5,3];

// Particles
let particles=[];
let floatingTexts=[];
let rareFlashTimer=0;

// Depth zone display
let depthZoneText='';
let depthZoneTimer=0;
let lastZoneIndex=-1;

// Stamina regen
let lastStaminaRegen=0;

// Wallet
let walletAddress=null;
let provider=null;
let signer=null;

// Daily missions
let dailyMissions=[];
let missionDateKey='';

// Random events
let nextEventTime=0;
let activeEvent=null; // {type, endTime}
let eventBannerTimeout=null;

// === MISSION SYSTEM ===
function getMissionDateKey(){
  const now=new Date();
  return `${now.getUTCFullYear()}-${now.getUTCMonth()}-${now.getUTCDate()}`;
}

function getMissionPool(){
  return [
    {id:'mine_coal',   type:'mine_ore', ore:COAL,      count:5,  desc:'Mine 5 Coal',           reward:50},
    {id:'mine_iron',   type:'mine_ore', ore:IRON,      count:3,  desc:'Mine 3 Iron',           reward:100},
    {id:'mine_gold',   type:'mine_ore', ore:GOLD,      count:2,  desc:'Mine 2 Gold',           reward:200},
    {id:'mine_diamond',type:'mine_ore', ore:DIAMOND,   count:1,  desc:'Mine 1 Diamond',        reward:300},
    {id:'mine_emerald',type:'mine_ore', ore:EMERALD,   count:1,  desc:'Mine 1 Emerald',        reward:350},
    {id:'mine_bai',    type:'mine_ore', ore:BAICRYSTAL,count:1,  desc:'Mine 1 BAI Crystal',    reward:500},
    {id:'depth_50',    type:'reach_depth',depth:50,    desc:'Reach depth 50m',                 reward:100},
    {id:'depth_100',   type:'reach_depth',depth:100,   desc:'Reach depth 100m',                reward:200},
    {id:'depth_150',   type:'reach_depth',depth:150,   desc:'Reach depth 150m',                reward:350},
    {id:'score_500',   type:'score',    target:500,    desc:'Score 500 points',                reward:100},
    {id:'score_2000',  type:'score',    target:2000,   desc:'Score 2000 points',               reward:250},
    {id:'survive',     type:'survive',               desc:'Survive without dying',              reward:150},
    {id:'mine_20',     type:'mine_total',count:20,    desc:'Mine 20 ores in session',           reward:150},
    {id:'mine_50',     type:'mine_total',count:50,    desc:'Mine 50 ores in session',           reward:300},
  ];
}

function loadDailyMissions(){
  missionDateKey=getMissionDateKey();
  const stored=localStorage.getItem('bai_missions_'+missionDateKey);
  if(stored){
    dailyMissions=JSON.parse(stored);
    return;
  }
  const pool=getMissionPool();
  const seed=(()=>{
    const parts=missionDateKey.split('-');
    return parseInt(parts[0])*10000+parseInt(parts[1])*100+parseInt(parts[2]);
  })();
  const r=mulberry32(seed);
  const missions=[];
  const used=new Set();
  while(missions.length<3&&used.size<pool.length){
    const idx=Math.floor(r()*pool.length);
    if(!used.has(idx)){
      used.add(idx);
      missions.push({...pool[idx],progress:0,completed:false});
    }
  }
  dailyMissions=missions;
  saveDailyMissions();
}

function saveDailyMissions(){
  localStorage.setItem('bai_missions_'+missionDateKey,JSON.stringify(dailyMissions));
}

function updateMissionProgress(){
  let anyComplete=false;
  for(const m of dailyMissions){
    if(m.completed) continue;
    let progress=0;
    switch(m.type){
      case 'mine_ore':    progress=player.inventory[m.ore]||0; break;
      case 'reach_depth': progress=player.maxDepth; break;
      case 'score':       progress=player.score; break;
      case 'survive':     progress=player.deaths===0?1:0; break;
      case 'mine_total':  progress=player.totalMined; break;
    }
    m.progress=progress;
    const target=m.count||m.depth||m.target||1;
    if(progress>=target&&!m.completed){
      m.completed=true;
      player.score+=m.reward;
      anyComplete=true;
      showMissionComplete(m);
      playMissionCompleteSound();
    }
  }
  if(anyComplete) saveDailyMissions();
}

function showMissionComplete(m){
  const el=document.getElementById('missionFlash');
  el.textContent='MISSION COMPLETE! +'+m.reward+' pts';
  el.style.opacity='1';
  setTimeout(()=>{ el.style.opacity='0'; },2500);
}

// === RANDOM EVENTS ===
function scheduleNextEvent(){
  nextEventTime=performance.now()+(45000+Math.random()*45000);
}

function triggerRandomEvent(){
  const types=['oreRush','bonusVein','caveIn','energySurge'];
  const type=types[Math.floor(Math.random()*types.length)];
  switch(type){
    case 'oreRush':
      activeEvent={type:'oreRush',endTime:performance.now()+30000};
      document.getElementById('oreRushOverlay').style.display='block';
      showEventBanner('\u26A1 ORE RUSH! 30s');
      playOreRushSound();
      break;
    case 'bonusVein':
      spawnBonusVein();
      showEventBanner('\u2728 BONUS VEIN NEARBY!');
      break;
    case 'caveIn':
      showEventBanner('\u26A0 CAVE-IN IN 5s!');
      setTimeout(triggerCaveIn,5000);
      break;
    case 'energySurge':
      player.stamina=player.maxStamina;
      player.invincible=true;
      setTimeout(()=>{player.invincible=false;},3000);
      showEventBanner('\u26A1 ENERGY SURGE!');
      playEnergySurgeSound();
      break;
  }
  scheduleNextEvent();
}

function spawnBonusVein(){
  const rareOres=[GOLD,DIAMOND,EMERALD,BAICRYSTAL];
  const ore=rareOres[Math.floor(Math.random()*rareOres.length)];
  const ox=Math.round((Math.random()-0.5)*12);
  const oy=Math.round(Math.random()*6+2);
  const cx=Math.max(1,Math.min(WORLD_W-2,player.x+ox));
  const cy=Math.max(1,Math.min(WORLD_H-2,player.y+oy));
  placeVein(cx,cy,ore,4+Math.floor(Math.random()*4));
}

function triggerCaveIn(){
  if(gameState!=='playing') return;
  const savedTiles=[];
  for(let dx=-1;dx<=1;dx++){
    for(let dy=-3;dy<=-1;dy++){
      const x=player.x+dx,y=player.y+dy;
      if(x<0||x>=WORLD_W||y<0||y>=WORLD_H) continue;
      const orig=getTile(x,y);
      if(orig===AIR||orig===CAVE){
        savedTiles.push({x,y,orig});
        setTile(x,y,STONE);
        setHP(x,y,BLOCK_DEF[STONE].hardness);
      }
    }
  }
  setTimeout(()=>{
    for(const s of savedTiles){
      if(getTile(s.x,s.y)===STONE){
        setTile(s.x,s.y,s.orig);
        setHP(s.x,s.y,0);
      }
    }
  },10000);
}

function showEventBanner(text){
  const el=document.getElementById('eventBanner');
  el.textContent=text;
  el.style.opacity='1';
  if(eventBannerTimeout) clearTimeout(eventBannerTimeout);
  eventBannerTimeout=setTimeout(()=>{ el.style.opacity='0'; },4000);
}

// === COMBO ===
function getComboMult(){
  return COMBO_MULT[Math.min(comboCount,4)];
}
function incrementCombo(){
  const now=performance.now();
  if(now-lastMineTime2<COMBO_TIMEOUT){
    comboCount=Math.min(comboCount+1,4);
  } else {
    comboCount=0;
  }
  lastMineTime2=now;
}

// === PARTICLES & FLOATING TEXT ===
function spawnParticles(wx,wy,color,count,comboLevel){
  const c2=comboLevel||1;
  for(let i=0;i<count*Math.min(c2,3);i++){
    particles.push({
      x:wx*TILE_SIZE+TILE_SIZE/2, y:wy*TILE_SIZE+TILE_SIZE/2,
      vx:(Math.random()-0.5)*(4+c2),
      vy:(Math.random()-0.5)*(4+c2)-2,
      life:30+Math.random()*20,
      maxLife:50,
      color:color,
      size:2+Math.random()*3+c2*0.5,
    });
  }
}

function addFloatingText(wx,wy,text,color){
  floatingTexts.push({
    x:wx*TILE_SIZE+TILE_SIZE/2,
    y:wy*TILE_SIZE-4,
    text,color,
    vy:-1.2,
    life:70,
    maxLife:70,
  });
}

function triggerShake(amount){
  shakeAmount=Math.max(shakeAmount,amount);
}

// === PICKAXE ===
function getCurrentPickaxe(){
  return PICKAXE_TIERS[player.pickaxeTier];
}
function upgradPickaxe(tier){
  const t=PICKAXE_TIERS[tier];
  if(tier<=player.pickaxeTier) return;
  if(player.score<t.cost) return;
  player.score-=t.cost;
  player.pickaxeTier=tier;
}

function openUpgradeMenu(){
  const overlay=document.getElementById('upgradeOverlay');
  overlay.style.display='flex';
  const cont=document.getElementById('upgradeTiers');
  cont.innerHTML='';
  PICKAXE_TIERS.forEach((t,i)=>{
    const div=document.createElement('div');
    div.className='upgrade-tier'+(i===player.pickaxeTier?' current':(player.score>=t.cost&&i>player.pickaxeTier?' affordable':''));
    div.innerHTML=`<h3>&#x26CF; ${t.name}</h3><p>Speed: ${t.cooldown}ms cooldown &bull; Power: x${t.power}</p>`+
      (i===0?'<div class="cost" style="color:#888">[ EQUIPPED ]</div>':
       i===player.pickaxeTier?'<div class="cost" style="color:#00ffc8">[ CURRENT ]</div>':
       i<player.pickaxeTier?'<div class="cost" style="color:#555">[ OWNED ]</div>':
       `<div class="cost">Cost: ${t.cost.toLocaleString()} pts${player.score>=t.cost?' \u2713':' \u2717'}</div>`);
    if(i>player.pickaxeTier&&player.score>=t.cost){
      div.style.cursor='pointer';
      div.addEventListener('click',()=>{ upgradPickaxe(i); openUpgradeMenu(); });
    }
    cont.appendChild(div);
  });
}

// === MINIMAP ===
function markExplored(px,py){
  const radius=7;
  for(let dx=-radius;dx<=radius;dx++){
    for(let dy=-radius;dy<=radius;dy++){
      if(dx*dx+dy*dy>radius*radius) continue;
      const x=px+dx,y=py+dy;
      if(x>=0&&x<WORLD_W&&y>=0&&y<WORLD_H) explored[y*WORLD_W+x]=1;
    }
  }
}

function drawMinimap(){
  if(!showMinimap) return;
  const mapSize=80;
  const mx=screenW-mapSize-10;
  const my=90;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.75)';
  ctx.fillRect(mx,my,mapSize,mapSize);
  ctx.strokeStyle='#00ffc833';
  ctx.lineWidth=1;
  ctx.strokeRect(mx,my,mapSize,mapSize);
  const half=mapSize/2;
  const imgData=ctx.createImageData(mapSize,mapSize);
  const data=imgData.data;
  for(let dy=0;dy<mapSize;dy++){
    for(let dx=0;dx<mapSize;dx++){
      const wx=player.x+dx-half;
      const wy=player.y+dy-half;
      if(wx<0||wx>=WORLD_W||wy<0||wy>=WORLD_H) continue;
      if(!explored[wy*WORLD_W+wx]) continue;
      const tile=getTile(wx,wy);
      if(tile===AIR||tile===CAVE) {
        const idx=(dy*mapSize+dx)*4;
        data[idx]=10;data[idx+1]=10;data[idx+2]=15;data[idx+3]=200;
        continue;
      }
      const def=BLOCK_DEF[tile];
      if(def.color==='transparent') continue;
      const r=parseInt(def.color.slice(1,3),16);
      const g=parseInt(def.color.slice(3,5),16);
      const b=parseInt(def.color.slice(5,7),16);
      const idx=(dy*mapSize+dx)*4;
      data[idx]=r;data[idx+1]=g;data[idx+2]=b;data[idx+3]=220;
    }
  }
  ctx.putImageData(imgData,mx,my);
  // Player dot
  ctx.fillStyle='#00ffc8';
  ctx.fillRect(mx+half-1,my+half-1,3,3);
  // Border again
  ctx.strokeStyle='#00ffc844';
  ctx.lineWidth=1;
  ctx.strokeRect(mx,my,mapSize,mapSize);
  ctx.font='7px monospace';
  ctx.fillStyle='#00ffc866';
  ctx.textAlign='left';
  ctx.fillText('[M]MAP',mx,my-2);
  ctx.restore();
}

// === WALLET ===
async function connectWallet(){
  if(!window.ethereum){ alert('No wallet found. Install MetaMask.'); return; }
  try{
    const prov=new ethers.BrowserProvider(window.ethereum);
    const network=await prov.getNetwork();
    if(Number(network.chainId)!==BASE_CHAIN_ID){
      try{
        await window.ethereum.request({
          method:'wallet_switchEthereumChain',
          params:[{chainId:'0x'+BASE_CHAIN_ID.toString(16)}],
        });
      }catch(switchErr){
        if(switchErr.code===4902){
          await window.ethereum.request({
            method:'wallet_addEthereumChain',
            params:[{
              chainId:'0x'+BASE_CHAIN_ID.toString(16),
              chainName:'Base',
              nativeCurrency:{name:'ETH',symbol:'ETH',decimals:18},
              rpcUrls:['https://mainnet.base.org'],
              blockExplorerUrls:['https://basescan.org'],
            }],
          });
        }
      }
    }
    const accounts=await prov.send('eth_requestAccounts',[]);
    walletAddress=accounts[0];
    provider=prov;
    signer=await prov.getSigner();
    const addr=walletAddress;
    const short=addr.slice(0,6)+'...'+addr.slice(-4);
    document.getElementById('walletAddr').textContent=short;
    document.getElementById('walletInfo').style.display='flex';
    document.getElementById('connectWalletBtn').style.display='none';
  }catch(e){
    console.error('Wallet connect error:',e);
  }
}

function openRedeemModal(){
  const gemTotal = calculateGemValue();
  const gemDisplay = gemTotal.toFixed(2);
  const meetsMin = gemTotal >= MIN_REDEEM_GEM;
  
  // Build breakdown
  const breakdown = buildOreBreakdownHTML();
  
  let statusMsg = '';
  if (!walletAddress) {
    statusMsg = '<p style="color:#ff6655;font-size:11px;margin-top:8px;">⚠ Connect your wallet to claim.</p>';
  } else if (!meetsMin) {
    statusMsg = `<p style="color:#ff9900;font-size:11px;margin-top:8px;">⚠ Minimum redemption is ${MIN_REDEEM_GEM} $GEM. Keep mining!</p>`;
  } else {
    statusMsg = `<p style="color:#00ffc8;font-size:11px;margin-top:8px;">✓ Wallet: ${walletAddress.slice(0,6)}...${walletAddress.slice(-4)}</p>`;
  }

  document.getElementById('redeemMsg').innerHTML = `
    <div style="margin-bottom:10px;">
      <div style="font-size:11px;color:#888;margin-bottom:6px;letter-spacing:1px;">ORE BREAKDOWN</div>
      <div class="redeem-breakdown">${breakdown}</div>
    </div>
    <div style="border-top:1px solid #333;padding-top:10px;margin-top:4px;">
      <span style="color:#aaa;font-size:12px;">TOTAL VALUE: </span>
      <strong style="color:#ffd700;font-size:18px;">${gemDisplay} $GEM</strong>
    </div>
    ${statusMsg}
    <p style="color:#444;font-size:10px;margin-top:8px;">Full on-chain redemption activates when the game server is live. Your claim is saved.</p>
  `;
  
  // Save pending claim
  const pending = {
    inventory: {...player.inventory},
    address: walletAddress,
    gemEstimate: gemTotal,
    timestamp: Date.now()
  };
  localStorage.setItem('bai_pending_redeem', JSON.stringify(pending));
  document.getElementById('redeemModal').style.display='flex';
}

// === HIGH SCORE ===
function getHighScore(){
  return parseInt(localStorage.getItem(HIGH_SCORE_KEY)||'0');
}
function saveHighScore(score){
  const cur=getHighScore();
  if(score>cur){ localStorage.setItem(HIGH_SCORE_KEY,score.toString()); return true; }
  return false;
}

// === DEPTH ZONE ===
function checkDepthZone(){
  const depth=Math.max(0,player.y-SURFACE_Y);
  player.maxDepth=Math.max(player.maxDepth,depth);
  let zoneIdx=0;
  for(let i=0;i<DEPTH_ZONES.length;i++){
    if(depth>=DEPTH_ZONES[i].minDepth) zoneIdx=i;
  }
  if(zoneIdx!==lastZoneIndex){
    lastZoneIndex=zoneIdx;
    depthZoneText=DEPTH_ZONES[zoneIdx].name;
    depthZoneTimer=120;
  }
}

// === MOVE / MINE ===
function getMoveCooldown(){
  return getCurrentPickaxe().cooldown;
}

function tryMove(dx,dy){
  if(player.dead||gameState!=='playing') return;
  const now=performance.now();
  if(now-lastMoveTime<getMoveCooldown()) return;
  lastMoveTime=now;
  const nx=player.x+dx,ny=player.y+dy;
  if(nx<0||nx>=WORLD_W||ny<0||ny>=WORLD_H) return;
  const tile=getTile(nx,ny);

  if(tile===AIR||tile===CAVE){
    player.x=nx; player.y=ny;
    markExplored(nx,ny);
    checkDepthZone();
  } else if(tile===LAVA){
    if(player.invincible) return;
    player.x=nx; player.y=ny;
    player.hp-=25; spawnParticles(nx,ny,'#ff6600',15,1);
    triggerShake(6);
    if(player.hp<=0) killPlayer();
    markExplored(nx,ny);
  } else if(tile===BEDROCK){
    spawnParticles(nx,ny,'#444444',3,1);
  } else {
    // Mining
    const staminaCost=STAMINA_COST[tile]||2;
    if(player.stamina<=0) return; // Can't mine
    player.stamina=Math.max(0,player.stamina-staminaCost);

    const power=getCurrentPickaxe().power;
    let hp=getHP(nx,ny);
    hp-=power;
    setHP(nx,ny,hp);
    const def=BLOCK_DEF[tile];
    spawnParticles(nx,ny,def.color,5,comboCount+1);
    playMineSound(def.hardness);

    if(hp<=0){
      incrementCombo();
      const mult=getComboMult();
      let value=def.value;
      // Ore Rush doubles value
      if(activeEvent&&activeEvent.type==='oreRush'&&performance.now()<activeEvent.endTime){
        value*=2;
      }
      const finalValue=Math.floor(value*mult);
      player.score+=finalValue;
      if(value>0){
        player.inventory[tile]=(player.inventory[tile]||0)+1;
        player.totalMined++;
      }
      setTile(nx,ny,CAVE); setHP(nx,ny,0);
      player.x=nx; player.y=ny;
      markExplored(nx,ny);
      checkDepthZone();

      // Floating text
      if(finalValue>0){
        const comboStr=mult>1?` x${mult}`:'';
        addFloatingText(nx,ny,'+'+finalValue+' pts'+comboStr,'#ffd700');
        if(def.value>=200){
          addFloatingText(nx,ny-1,def.name,'#'+BLOCK_DEF[tile].color.replace('#',''));
        }
      }

      // Rare ore effects
      if(value>=40){
        rareFlashTimer=15;
        document.getElementById('rareFlash').style.background=
          `radial-gradient(circle, ${def.color}44 0%, transparent 70%)`;
        if(value>=200){
          triggerShake(8);
          playRareOreSound();
        }
      }

      // Combo flash on screen (handled in render)
      updateMissionProgress();
    } else {
      // Show damage number
      addFloatingText(nx,ny,'HP:'+Math.ceil(hp),'#888888');
    }
  }
}

function killPlayer(){
  if(player.invincible) return;
  player.dead=true; player.hp=0;
  player.deaths++;
  const finalScore=Math.floor(player.score*0.9);
  const isNewHigh=saveHighScore(player.score);
  player.score=finalScore;
  triggerShake(15);
  playDeathSound();

  const deathEl=document.getElementById('deathOverlay');
  document.getElementById('deathScore').textContent='Score: '+player.score.toLocaleString()+' pts';
  document.getElementById('deathBest').textContent='Best: '+getHighScore().toLocaleString()+' pts';
  const newEl=document.getElementById('deathNew');
  newEl.style.display=isNewHigh?'block':'none';
  const claimBtn=document.getElementById('deathClaimBtn');
  claimBtn.style.display=(walletAddress&&player.score>0)?'block':'none';
  deathEl.style.display='flex';

  player.respawnTimer=300; // 5 seconds, or press Enter
}

function respawnPlayer(){
  player.dead=false; player.hp=player.maxHp; player.x=100;
  player.stamina=player.maxStamina;
  for(let y=0;y<WORLD_H;y++){
    const t=getTile(player.x,y);
    if(t!==AIR){player.y=y-1;break;}
  }
  document.getElementById('deathOverlay').style.display='none';
  comboCount=0;
}

// === INPUT ===
function onKeyDown(e){
  if(gameState==='start'){
    if(e.key==='Enter'||e.key===' '){startGame();e.preventDefault();}
    return;
  }
  if(gameState==='playing'&&player.dead){
    if(e.key==='Enter'){ respawnPlayer(); e.preventDefault(); }
    return;
  }
  // Upgrade menu toggle
  if(e.key.toLowerCase()==='u'){
    const overlay=document.getElementById('upgradeOverlay');
    if(overlay.style.display==='flex'){
      overlay.style.display='none';
    } else {
      openUpgradeMenu();
    }
    e.preventDefault(); return;
  }
  // Minimap toggle
  if(e.key.toLowerCase()==='m'){
    showMinimap=!showMinimap;
    e.preventDefault(); return;
  }
  // Close overlays
  if(e.key==='Escape'){
    document.getElementById('upgradeOverlay').style.display='none';
    document.getElementById('redeemModal').style.display='none';
    e.preventDefault(); return;
  }
  keysDown[e.key.toLowerCase()]=true;
  const now=performance.now();
  if(now-lastMoveTime<getMoveCooldown()) return;
  let dx=0,dy=0;
  if(e.key==='ArrowUp'||e.key.toLowerCase()==='w') dy=-1;
  else if(e.key==='ArrowDown'||e.key.toLowerCase()==='s') dy=1;
  else if(e.key==='ArrowLeft'||e.key.toLowerCase()==='a') dx=-1;
  else if(e.key==='ArrowRight'||e.key.toLowerCase()==='d') dx=1;
  if(dx||dy){tryMove(dx,dy);e.preventDefault();}
}
function onKeyUp(e){ keysDown[e.key.toLowerCase()]=false; }

function onTouch(e){
  e.preventDefault();
  if(gameState==='start'){startGame();return;}
  const touch=e.touches[0];
  handleClickAt(touch.clientX,touch.clientY);
}
function onClick(e){
  if(gameState==='start'){startGame();return;}
  handleClickAt(e.clientX,e.clientY);
}
function handleClickAt(cx,cy){
  if(gameState!=='playing'||player.dead) return;
  const worldX=Math.floor((cx+camX+shakeX)/TILE_SIZE);
  const worldY=Math.floor((cy+camY+shakeY)/TILE_SIZE);
  const dx=worldX-player.x,dy=worldY-player.y;
  if(Math.abs(dx)+Math.abs(dy)===1) tryMove(dx,dy);
  else if(Math.abs(dx)<=1&&Math.abs(dy)<=1&&(dx||dy)){
    if(Math.abs(dx)>=Math.abs(dy)) tryMove(dx>0?1:-1,0);
    else tryMove(0,dy>0?1:-1);
  }
}

// === GAME INIT ===
function init(){
  canvas=document.getElementById('gameCanvas');
  ctx=canvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize',resizeCanvas);
  window.addEventListener('keydown',onKeyDown);
  window.addEventListener('keyup',onKeyUp);

  document.querySelectorAll('.mBtn').forEach(btn=>{
    const handler=(e)=>{
      e.preventDefault();
      const dir=btn.dataset.dir;
      if(dir==='up') tryMove(0,-1);
      else if(dir==='down') tryMove(0,1);
      else if(dir==='left') tryMove(-1,0);
      else if(dir==='right') tryMove(1,0);
    };
    btn.addEventListener('touchstart',handler,{passive:false});
    btn.addEventListener('mousedown',handler);
  });

  canvas.addEventListener('touchstart',onTouch,{passive:false});
  canvas.addEventListener('click',onClick);

  // Wallet buttons
  document.getElementById('connectWalletBtn').addEventListener('click',connectWallet);
  document.getElementById('redeemBtn').addEventListener('click',openRedeemModal);
  document.getElementById('redeemClose').addEventListener('click',()=>{
    document.getElementById('redeemModal').style.display='none';
  });
  document.getElementById('upgradeClose').addEventListener('click',()=>{
    document.getElementById('upgradeOverlay').style.display='none';
  });
  document.getElementById('deathRestartBtn').addEventListener('click',respawnPlayer);
  document.getElementById('deathClaimBtn').addEventListener('click',openRedeemModal);

  // Show best score on start screen
  const hs=getHighScore();
  if(hs>0){
    const el=document.getElementById('startBest');
    el.textContent='BEST: '+hs.toLocaleString()+' pts';
    el.style.display='block';
  }

  startScreenAnim();
}

function resizeCanvas(){
  const dpr=window.devicePixelRatio||1;
  screenW=window.innerWidth; screenH=window.innerHeight;
  canvas.width=screenW*dpr; canvas.height=screenH*dpr;
  canvas.style.width=screenW+'px'; canvas.style.height=screenH+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

let startParticles=[];
function startScreenAnim(){
  const sc=document.getElementById('startCanvas');
  const sctx=sc.getContext('2d');
  const dpr=window.devicePixelRatio||1;
  function resizeSC(){
    sc.width=window.innerWidth*dpr; sc.height=window.innerHeight*dpr;
    sctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resizeSC();
  window.addEventListener('resize',resizeSC);
  for(let i=0;i<80;i++){
    startParticles.push({
      x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight,
      vx:(Math.random()-0.5)*0.5, vy:-Math.random()*0.8-0.2,
      size:Math.random()*3+1, alpha:Math.random()*0.5+0.2,
      color:['#00ffc8','#00ff88','#88ffdd','#ffd700'][Math.floor(Math.random()*4)],
    });
  }
  function animStart(){
    if(gameState!=='start') return;
    sctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    for(const p of startParticles){
      sctx.globalAlpha=p.alpha; sctx.fillStyle=p.color;
      sctx.beginPath(); sctx.arc(p.x,p.y,p.size,0,Math.PI*2); sctx.fill();
      p.x+=p.vx; p.y+=p.vy;
      if(p.y<-10){p.y=window.innerHeight+10;p.x=Math.random()*window.innerWidth;}
      if(p.x<-10) p.x=window.innerWidth+10;
      if(p.x>window.innerWidth+10) p.x=-10;
    }
    sctx.globalAlpha=1;
    requestAnimationFrame(animStart);
  }
  animStart();
}

function startGame(){
  if(gameState==='playing') return;
  const seed=Date.now();
  generateWorld(seed);
  player.x=100;
  for(let y=0;y<WORLD_H;y++){
    const t=getTile(player.x,y);
    if(t!==AIR){player.y=y-1;break;}
  }
  player.hp=100; player.score=0; player.inventory={};
  player.dead=false; player.stamina=100; player.pickaxeTier=0;
  player.totalMined=0; player.deaths=0; player.maxDepth=0;
  comboCount=0; lastMineTime2=0;
  lastZoneIndex=-1; depthZoneTimer=0;
  shakeAmount=0; shakeX=0; shakeY=0;
  activeEvent=null;
  document.getElementById('oreRushOverlay').style.display='none';

  camX=player.x*TILE_SIZE-screenW/2;
  camY=player.y*TILE_SIZE-screenH/2;
  targetCamX=camX; targetCamY=camY;

  loadDailyMissions();
  scheduleNextEvent();

  markExplored(player.x,player.y);

  document.getElementById('startScreen').style.display='none';
  document.getElementById('hud').style.display='block';
  gameState='playing';
  lastTime=performance.now();
  requestAnimationFrame(gameLoop);
}

// === GAME LOOP ===
let lastTime=0;
function gameLoop(timestamp){
  if(gameState!=='playing') return;
  const dt=timestamp-lastTime; lastTime=timestamp; animTime=timestamp;
  const now=performance.now();

  // Key repeat movement
  if(now-lastMoveTime>=getMoveCooldown()&&!player.dead){
    const upgradeOpen=document.getElementById('upgradeOverlay').style.display==='flex';
    if(!upgradeOpen){
      if(keysDown['w']||keysDown['arrowup']) tryMove(0,-1);
      else if(keysDown['s']||keysDown['arrowdown']) tryMove(0,1);
      else if(keysDown['a']||keysDown['arrowleft']) tryMove(-1,0);
      else if(keysDown['d']||keysDown['arrowright']) tryMove(1,0);
    }
  }

  // Combo timeout
  if(comboCount>0&&now-lastMineTime2>COMBO_TIMEOUT){
    comboCount=0;
  }

  // Gravity
  if(!player.dead&&timestamp-lastGravity>GRAVITY_INTERVAL){
    lastGravity=timestamp;
    const below=getTile(player.x,player.y+1);
    if(below===AIR||below===CAVE){
      player.y++;
      markExplored(player.x,player.y);
      checkDepthZone();
    } else if(below===LAVA){
      if(!player.invincible){
        player.y++; player.hp-=25;
        spawnParticles(player.x,player.y,'#ff6600',15,1);
        triggerShake(6);
        if(player.hp<=0) killPlayer();
      }
    }
  }

  // Lava standing damage
  if(!player.dead&&timestamp-lastLavaTick>LAVA_TICK){
    lastLavaTick=timestamp;
    if(getTile(player.x,player.y)===LAVA&&!player.invincible){
      player.hp-=25; if(player.hp<=0) killPlayer();
    }
  }

  // Stamina regen
  if(!player.dead&&now-lastStaminaRegen>200){
    lastStaminaRegen=now;
    if(player.stamina<player.maxStamina){
      player.stamina=Math.min(player.maxStamina,player.stamina+1);
    }
  }

  // Auto respawn countdown
  if(player.dead){
    player.respawnTimer--;
    if(player.respawnTimer<=0) respawnPlayer();
  }

  // Random events
  if(!player.dead&&now>=nextEventTime&&nextEventTime>0){
    triggerRandomEvent();
  }

  // Ore rush end check
  if(activeEvent&&activeEvent.type==='oreRush'&&now>activeEvent.endTime){
    activeEvent=null;
    document.getElementById('oreRushOverlay').style.display='none';
  }

  // Screen shake decay
  if(shakeAmount>0){
    shakeX=(Math.random()-0.5)*shakeAmount*2;
    shakeY=(Math.random()-0.5)*shakeAmount*2;
    shakeAmount*=0.82;
    if(shakeAmount<0.4){shakeAmount=0;shakeX=0;shakeY=0;}
  }

  // Update particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.15; p.life--;
    if(p.life<=0) particles.splice(i,1);
  }
  for(let i=floatingTexts.length-1;i>=0;i--){
    const ft=floatingTexts[i];
    ft.y+=ft.vy; ft.life--;
    if(ft.life<=0) floatingTexts.splice(i,1);
  }

  if(rareFlashTimer>0){
    rareFlashTimer--;
    document.getElementById('rareFlash').style.opacity=rareFlashTimer/15;
  }

  // Depth zone timer
  if(depthZoneTimer>0) depthZoneTimer--;

  // Camera
  targetCamX=player.x*TILE_SIZE+TILE_SIZE/2-screenW/2;
  targetCamY=player.y*TILE_SIZE+TILE_SIZE/2-screenH/2;
  camX+=(targetCamX-camX)*0.12;
  camY+=(targetCamY-camY)*0.12;

  render();
  updateHUD();
  requestAnimationFrame(gameLoop);
}

// === RENDER ===
function render(){
  const rcx=camX+shakeX, rcy=camY+shakeY;
  ctx.clearRect(0,0,screenW,screenH);

  const startTileX=Math.floor(rcx/TILE_SIZE)-1;
  const startTileY=Math.floor(rcy/TILE_SIZE)-1;
  const endTileX=Math.ceil((rcx+screenW)/TILE_SIZE)+1;
  const endTileY=Math.ceil((rcy+screenH)/TILE_SIZE)+1;

  // Sky
  const skyBottom=SURFACE_Y*TILE_SIZE-rcy;
  if(skyBottom>0){
    const grad=ctx.createLinearGradient(0,Math.max(0,-rcy),0,skyBottom);
    grad.addColorStop(0,'#0a0a2e'); grad.addColorStop(0.5,'#0d1b3e'); grad.addColorStop(1,'#1a2a4a');
    ctx.fillStyle=grad; ctx.fillRect(0,0,screenW,Math.min(skyBottom,screenH));
  }

  // Underground bg
  for(let y=startTileY;y<=endTileY;y++){
    if(y<SURFACE_Y) continue;
    const depth=y-SURFACE_Y;
    const darkness=Math.min(depth/200,1);
    const r=Math.floor(lerp(15,3,darkness));
    const g=Math.floor(lerp(12,2,darkness));
    const b=Math.floor(lerp(20,8,darkness));
    const sy=y*TILE_SIZE-rcy;
    ctx.fillStyle=`rgb(${r},${g},${b})`;
    ctx.fillRect(0,sy,screenW,TILE_SIZE+1);
  }

  // Tiles
  for(let y=startTileY;y<=endTileY;y++){
    for(let x=startTileX;x<=endTileX;x++){
      const tile=getTile(x,y);
      if(tile===AIR||tile===CAVE) continue;
      const sx=Math.floor(x*TILE_SIZE-rcx);
      const sy=Math.floor(y*TILE_SIZE-rcy);
      drawTile(ctx,tile,x,y,sx,sy);
    }
  }

  // Player
  if(!player.dead){
    const px=Math.floor(player.x*TILE_SIZE-rcx);
    const py=Math.floor(player.y*TILE_SIZE-rcy);
    drawPlayer(px,py);
  }

  // Particles
  for(const p of particles){
    const sx=p.x-rcx,sy=p.y-rcy;
    ctx.globalAlpha=Math.max(0,p.life/p.maxLife);
    ctx.fillStyle=p.color;
    ctx.fillRect(sx-p.size/2,sy-p.size/2,p.size,p.size);
  }
  ctx.globalAlpha=1;

  // Floating texts
  ctx.save();
  ctx.textAlign='center';
  for(const ft of floatingTexts){
    const sx=ft.x-rcx,sy=ft.y-rcy;
    ctx.globalAlpha=Math.max(0,ft.life/ft.maxLife);
    ctx.fillStyle=ft.color;
    ctx.font='bold 11px monospace';
    ctx.fillText(ft.text,sx,sy);
  }
  ctx.globalAlpha=1;
  ctx.restore();

  // Combo display
  if(comboCount>0&&!player.dead){
    const mult=getComboMult();
    const px=Math.floor(player.x*TILE_SIZE-rcx);
    const py=Math.floor(player.y*TILE_SIZE-rcy);
    const colors=['#ffd700','#ff8800','#ff4400','#ff00ff','#00ffff'];
    ctx.save();
    ctx.font=`bold ${14+comboCount*3}px monospace`;
    ctx.fillStyle=colors[comboCount];
    ctx.textAlign='center';
    ctx.shadowColor=colors[comboCount];
    ctx.shadowBlur=10;
    ctx.fillText('COMBO x'+mult,px+TILE_SIZE/2,py-16);
    ctx.restore();
  }

  // Depth zone atmospheric text
  if(depthZoneTimer>0){
    const alpha=Math.min(1,depthZoneTimer/30)*Math.min(1,(depthZoneTimer<90?depthZoneTimer/30:1));
    const zone=DEPTH_ZONES[lastZoneIndex<0?0:lastZoneIndex];
    ctx.save();
    ctx.globalAlpha=alpha*0.7;
    ctx.font='bold clamp(20px,4vw,36px) monospace';
    ctx.fillStyle=zone?zone.color:'#88ffaa';
    ctx.textAlign='center';
    ctx.letterSpacing='6px';
    ctx.shadowColor=zone?zone.color:'#88ffaa';
    ctx.shadowBlur=20;
    ctx.fillText(depthZoneText,screenW/2,screenH/2);
    ctx.restore();
  }

  // Minimap
  drawMinimap();
}

function drawTile(ctx,tile,wx,wy,sx,sy){
  const def=BLOCK_DEF[tile]; const S=TILE_SIZE; const t=animTime*0.001;
  ctx.fillStyle=def.color; ctx.fillRect(sx,sy,S,S);

  switch(tile){
    case GRASS:
      ctx.fillStyle='#5a9c4f'; ctx.fillRect(sx,sy,S,3);
      ctx.fillStyle='#3a6c2f';
      for(let i=0;i<5;i++){ctx.fillRect(sx+((wx*7+i*13)%S),sy+3,2,3);}
      break;
    case DIRT:
      ctx.fillStyle='#7a5a10';
      for(let i=0;i<4;i++){ctx.fillRect(((wx*5+wy*3+i*11)%(S-4))+sx,((wy*7+wx*2+i*7)%(S-4))+sy,3,3);}
      ctx.fillStyle='#9b7924';
      for(let i=0;i<3;i++){ctx.fillRect(((wx*3+wy*11+i*17)%(S-2))+sx,((wy*5+wx*8+i*13)%(S-2))+sy,2,2);}
      break;
    case STONE:
      ctx.fillStyle='#707070'; ctx.fillRect(sx+1,sy+1,S-2,S/2-1);
      ctx.fillStyle='#909090'; ctx.fillRect(sx+S/2,sy+S/2,S/2-1,S/2-1);
      ctx.strokeStyle='#60606060'; ctx.lineWidth=0.5; ctx.strokeRect(sx+2,sy+2,S-4,S/2-2);
      break;
    case COAL:
      ctx.fillStyle='#222222';
      for(let i=0;i<3;i++){ctx.fillRect(((wx*9+i*11)%(S-8))+sx+2,((wy*7+i*13)%(S-8))+sy+2,6,6);}
      break;
    case COPPER:
      ctx.fillStyle='#d4884a';
      for(let i=0;i<4;i++){
        const cx=((wx*7+i*9)%(S-6))+sx+2,cy=((wy*11+i*7)%(S-6))+sy+2;
        ctx.beginPath(); ctx.arc(cx+3,cy+3,3,0,Math.PI*2); ctx.fill();
      }
      break;
    case IRON:
      ctx.fillStyle='#b8b8c8';
      for(let i=0;i<3;i++){ctx.fillRect(((wx*13+i*7)%(S-8))+sx+3,((wy*9+i*11)%(S-6))+sy+2,5,4);}
      ctx.fillStyle='#888898'; ctx.fillRect(sx+4,sy+4,6,5);
      break;
    case SILVER:{
      const shimmer=Math.sin(t*3+wx+wy)*0.15+0.85;
      ctx.fillStyle=`rgba(220,220,235,${shimmer})`; ctx.fillRect(sx+2,sy+2,S-4,S-4);
      ctx.fillStyle='#e8e8f0'; ctx.fillRect(sx+6,sy+4,8,6); ctx.fillRect(sx+14,sy+14,10,8);
      const hx=sx+(Math.sin(t*2+wx)*0.5+0.5)*(S-6)+3;
      ctx.fillStyle=`rgba(255,255,255,${0.3+Math.sin(t*4)*0.2})`; ctx.fillRect(hx,sy+4,3,3);
      break;
    }
    case GOLD:{
      const glow=Math.sin(t*2+wx*0.5+wy*0.3)*0.15+0.85;
      ctx.fillStyle=`rgba(255,215,0,${glow})`; ctx.fillRect(sx+2,sy+2,S-4,S-4);
      ctx.fillStyle='#ffea55'; ctx.fillRect(sx+6,sy+6,8,8); ctx.fillRect(sx+16,sy+4,6,6);
      ctx.fillStyle='#cc9900'; ctx.fillRect(sx+4,sy+18,10,6);
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=6;
      ctx.fillStyle='rgba(255,215,0,0.3)'; ctx.fillRect(sx,sy,S,S); ctx.shadowBlur=0;
      break;
    }
    case DIAMOND:{
      const sparkle=Math.sin(t*5+wx*2+wy)*0.3+0.7;
      ctx.fillStyle='#004455'; ctx.fillRect(sx,sy,S,S);
      ctx.fillStyle=`rgba(0,255,255,${sparkle})`;
      ctx.beginPath(); ctx.moveTo(sx+S/2,sy+4); ctx.lineTo(sx+S-4,sy+S/2);
      ctx.lineTo(sx+S/2,sy+S-4); ctx.lineTo(sx+4,sy+S/2); ctx.closePath(); ctx.fill();
      ctx.fillStyle=`rgba(200,255,255,${Math.sin(t*8+wx)*0.5+0.5})`;
      ctx.fillRect(sx+8,sy+8,2,2); ctx.fillRect(sx+20,sy+14,2,2); ctx.fillRect(sx+14,sy+22,2,2);
      ctx.shadowColor='#00ffff'; ctx.shadowBlur=8;
      ctx.fillRect(sx+S/2-1,sy+S/2-1,2,2); ctx.shadowBlur=0;
      break;
    }
    case EMERALD:{
      const glow=Math.sin(t*3+wx+wy*2)*0.2+0.8;
      ctx.fillStyle='#1a4a2a'; ctx.fillRect(sx,sy,S,S);
      ctx.fillStyle=`rgba(80,200,120,${glow})`;
      ctx.beginPath(); ctx.moveTo(sx+8,sy+4); ctx.lineTo(sx+24,sy+4); ctx.lineTo(sx+28,sy+16);
      ctx.lineTo(sx+24,sy+28); ctx.lineTo(sx+8,sy+28); ctx.lineTo(sx+4,sy+16); ctx.closePath(); ctx.fill();
      ctx.shadowColor='#50c878'; ctx.shadowBlur=8;
      ctx.fillStyle='rgba(80,200,120,0.4)'; ctx.fillRect(sx+10,sy+10,12,12); ctx.shadowBlur=0;
      break;
    }
    case BAICRYSTAL:{
      const pulse=Math.sin(t*4+wx+wy)*0.3+0.7;
      ctx.fillStyle='#2a0040'; ctx.fillRect(sx,sy,S,S);
      ctx.fillStyle=`rgba(255,0,255,${pulse})`; ctx.fillRect(sx+4,sy+4,S-8,S-8);
      ctx.fillStyle=`rgba(255,100,255,${pulse*0.8})`;
      ctx.beginPath(); ctx.moveTo(sx+S/2,sy+2); ctx.lineTo(sx+S-6,sy+S/2);
      ctx.lineTo(sx+S/2,sy+S-2); ctx.lineTo(sx+6,sy+S/2); ctx.closePath(); ctx.fill();
      ctx.shadowColor='#ff00ff'; ctx.shadowBlur=12;
      ctx.fillStyle='rgba(255,0,255,0.3)'; ctx.fillRect(sx,sy,S,S); ctx.shadowBlur=0;
      break;
    }
    case VOIDORE:{
      const anim=Math.sin(t*2+wx*0.5+wy*0.5),anim2=Math.cos(t*3+wx+wy);
      ctx.fillStyle='#0a0018'; ctx.fillRect(sx,sy,S,S);
      ctx.fillStyle=`rgba(100,0,170,${0.5+anim*0.3})`;
      ctx.beginPath(); ctx.arc(sx+S/2+anim*4,sy+S/2+anim2*4,10,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`rgba(180,0,255,${0.4+anim2*0.3})`;
      ctx.beginPath(); ctx.arc(sx+S/2-anim2*3,sy+S/2+anim*3,6,0,Math.PI*2); ctx.fill();
      ctx.shadowColor='#6a00aa'; ctx.shadowBlur=15;
      ctx.strokeStyle=`rgba(150,0,255,${0.5+anim*0.3})`; ctx.lineWidth=1.5;
      ctx.strokeRect(sx+2,sy+2,S-4,S-4); ctx.shadowBlur=0;
      ctx.fillStyle=`rgba(220,150,255,${0.6+anim*0.3})`; ctx.fillRect(sx+13,sy+13,6,6);
      break;
    }
    case BEDROCK:
      ctx.fillStyle='#252525'; ctx.fillRect(sx+2,sy,S-4,S/2);
      ctx.fillStyle='#111111'; ctx.fillRect(sx,sy+S/2,S/2,S/2);
      ctx.fillRect(sx+S/2+2,sy+S/2,S/2-2,S/2);
      ctx.strokeStyle='#0a0a0a'; ctx.lineWidth=0.5; ctx.strokeRect(sx,sy,S,S);
      break;
    case LAVA:{
      const la=Math.sin(t*2+wx*0.3+wy*0.5),la2=Math.cos(t*1.5+wx*0.7);
      ctx.fillStyle='#cc2200'; ctx.fillRect(sx,sy,S,S);
      ctx.fillStyle=`rgba(255,100,0,${0.6+la*0.3})`; ctx.fillRect(sx+2,sy+2,S-4,S-4);
      ctx.fillStyle=`rgba(255,200,50,${0.4+la2*0.3})`;
      ctx.beginPath(); ctx.arc(sx+10+la*4,sy+10+la2*3,6,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(sx+22-la2*3,sy+20+la*2,5,0,Math.PI*2); ctx.fill();
      ctx.shadowColor='#ff4400'; ctx.shadowBlur=10;
      ctx.fillStyle='rgba(255,68,0,0.2)'; ctx.fillRect(sx,sy,S,S); ctx.shadowBlur=0;
      break;
    }
  }

  // Damage cracks
  if(tile!==AIR&&tile!==CAVE&&tile!==BEDROCK&&tile!==LAVA){
    const maxHP=BLOCK_DEF[tile].hardness,curHP=getHP(wx,wy);
    if(curHP<maxHP&&maxHP>0){
      const dmgRatio=1-(curHP/maxHP);
      ctx.strokeStyle=`rgba(0,0,0,${0.3+dmgRatio*0.5})`; ctx.lineWidth=1+dmgRatio*2;
      const inset=4;
      ctx.beginPath();
      ctx.moveTo(sx+inset,sy+inset); ctx.lineTo(sx+S-inset,sy+S-inset);
      ctx.moveTo(sx+S-inset,sy+inset); ctx.lineTo(sx+inset,sy+S-inset);
      if(dmgRatio>0.3){ctx.moveTo(sx+S/2,sy+inset); ctx.lineTo(sx+S/2,sy+S-inset);}
      if(dmgRatio>0.6){ctx.moveTo(sx+inset,sy+S/2); ctx.lineTo(sx+S-inset,sy+S/2);}
      ctx.stroke();
      ctx.fillStyle=`rgba(255,255,255,${dmgRatio*0.15})`; ctx.fillRect(sx,sy,S,S);
    }
  }
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=0.5; ctx.strokeRect(sx,sy,S,S);
}

function drawPlayer(px,py){
  const S=TILE_SIZE,t=animTime*0.003;

  // Invincibility flash
  if(player.invincible&&Math.floor(animTime/100)%2===0){
    ctx.globalAlpha=0.4;
  }

  // === HARD HAT ===
  ctx.fillStyle='#ff9900'; // brim
  ctx.fillRect(px+4,py+5,24,3);
  ctx.fillStyle='#ffaa00'; // dome
  ctx.fillRect(px+8,py+1,16,5);
  ctx.fillStyle='#ffcc44'; // dome highlight
  ctx.fillRect(px+10,py+2,5,2);

  // Headlamp (animated glow)
  const lamp=0.6+Math.sin(t*2.5)*0.4;
  ctx.shadowColor='#ffffbb'; ctx.shadowBlur=14*lamp;
  ctx.fillStyle=`rgba(255,255,160,${lamp})`;
  ctx.fillRect(px+14,py+2,4,3);
  ctx.shadowBlur=0;

  // === FACE ===
  ctx.fillStyle='#f5c99a';
  ctx.fillRect(px+8,py+8,16,9); // face
  // Eyes
  ctx.fillStyle='#111122';
  ctx.fillRect(px+10,py+10,3,3);
  ctx.fillRect(px+19,py+10,3,3);
  // Eye shine
  ctx.fillStyle='#ffffff';
  ctx.fillRect(px+11,py+10,1,1);
  ctx.fillRect(px+20,py+10,1,1);
  // Stubble
  ctx.fillStyle='rgba(0,0,0,0.1)';
  ctx.fillRect(px+10,py+15,12,2);
  // Smile
  ctx.fillStyle='#7a3010';
  ctx.fillRect(px+12,py+15,2,1);
  ctx.fillRect(px+14,py+16,4,1);
  ctx.fillRect(px+18,py+15,2,1);

  // === OVERALLS ===
  ctx.fillStyle='#2255aa';
  ctx.fillRect(px+6,py+17,20,9); // torso
  // Collar / undershirt
  ctx.fillStyle='#dddddd';
  ctx.fillRect(px+12,py+17,8,3);
  // Straps
  ctx.fillStyle='#1a4499';
  ctx.fillRect(px+9,py+17,4,9);
  ctx.fillRect(px+19,py+17,4,9);
  // Belt
  ctx.fillStyle='#7a5000';
  ctx.fillRect(px+8,py+24,16,2);
  ctx.fillStyle='#ffd700'; // buckle
  ctx.fillRect(px+14,py+24,4,2);

  // === ARMS (swing animation) ===
  const swing=Math.sin(t*5)*2;
  ctx.fillStyle='#2255aa';
  ctx.fillRect(px+2,py+17,4,8+swing);  // left arm
  ctx.fillRect(px+26,py+17,4,8-swing); // right arm
  ctx.fillStyle='#f5c99a';
  ctx.fillRect(px+2,py+25+swing,4,3);  // left hand
  ctx.fillRect(px+26,py+25-swing,4,3); // right hand

  // === PICKAXE (right hand) ===
  ctx.fillStyle='#7a4a1e'; // handle
  ctx.fillRect(px+28,py+23-swing,2,8);
  ctx.fillStyle='#b8b8b8'; // head
  ctx.fillRect(px+24,py+20-swing,8,3);
  ctx.fillStyle='#d8d8d8'; // tip (pick end)
  ctx.fillRect(px+22,py+19-swing,3,2);
  ctx.fillRect(px+22,py+22-swing,3,2);

  // === LEGS ===
  ctx.fillStyle='#1a4488';
  ctx.fillRect(px+8,py+26,6,5);  // left leg
  ctx.fillRect(px+18,py+26,6,5); // right leg

  // === BOOTS ===
  ctx.fillStyle='#5c3317';
  ctx.fillRect(px+6,py+29,10,3); // left boot
  ctx.fillRect(px+16,py+29,10,3); // right boot
  // Boot shine
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(px+7,py+29,3,1);
  ctx.fillRect(px+17,py+29,3,1);

  ctx.globalAlpha=1;
}

// === HUD UPDATE ===
function updateHUD(){
  const depth=Math.max(0,Math.floor(player.y-SURFACE_Y));
  document.getElementById('depth').textContent=`Depth: ${depth}m`;
  document.getElementById('score').textContent=`\u26CF ${player.score.toLocaleString()} ORE`;

  const pickaxe=getCurrentPickaxe();
  document.getElementById('pickaxeDisplay').textContent=`\u26CF ${pickaxe.name}`;

  // Health
  const hpPct=Math.max(0,player.hp/player.maxHp)*100;
  document.getElementById('healthBarInner').style.width=hpPct+'%';
  document.getElementById('healthText').textContent=`HP: ${Math.max(0,player.hp)} / ${player.maxHp}`;

  // Stamina
  const stPct=Math.max(0,player.stamina/player.maxStamina)*100;
  document.getElementById('staminaBarInner').style.width=stPct+'%';
  document.getElementById('energyLabel').textContent=`ENERGY: ${Math.ceil(player.stamina)}/${player.maxStamina}`;
  const lowEl=document.getElementById('lowEnergyText');
  if(player.stamina<=0){
    lowEl.classList.add('lowEnergyFlicker');
  } else {
    lowEl.classList.remove('lowEnergyFlicker');
    lowEl.style.display='none';
  }

  // Inventory
  const invEl=document.getElementById('inventory');
  let html='<div style="color:#00ffc8;margin-bottom:4px;font-weight:bold;font-size:10px;">INVENTORY</div>';
  const oreOrder=[DIRT,STONE,COAL,COPPER,IRON,SILVER,GOLD,DIAMOND,EMERALD,BAICRYSTAL,VOIDORE];
  let hasAny=false;
  for(const id of oreOrder){
    const count=player.inventory[id]||0;
    if(count===0) continue;
    hasAny=true;
    const def=BLOCK_DEF[id];
    html+=`<div class="inv-row"><span class="inv-icon" style="background:${def.color};"></span>${def.name}: ${count}</div>`;
  }
  if(!hasAny) html+='<div style="color:#444;font-size:9px;">empty</div>';
  invEl.innerHTML=html;

  // Missions
  const mList=document.getElementById('missionList');
  let mHtml='';
  for(const m of dailyMissions){
    const target=m.count||m.depth||m.target||1;
    const prog=Math.min(m.progress||0,target);
    const done=m.completed;
    mHtml+=`<div class="mission-item${done?' done':''}">
      <div class="mission-check">${done?'&#x2713;':''}</div>
      <div>
        <div>${m.desc}</div>
        <div style="color:${done?'#ffd700':'#555'};font-size:9px;">${done?'COMPLETE +'+m.reward:''+prog+'/'+target}</div>
      </div>
    </div>`;
  }
  mList.innerHTML=mHtml;
}

// === BOOTSTRAP ===
window.addEventListener('DOMContentLoaded',init);
document.addEventListener('touchstart',function(e){
  if(gameState==='start'){e.preventDefault();startGame();}
},{passive:false,once:true});

function toggleMissions(){
  const overlay = document.getElementById('missionsOverlay');
  const opening = !overlay.classList.contains('open');
  overlay.classList.toggle('open');
  if(opening) updateHUD(); // populate mission list on open
}
</script>
</body>
</html>